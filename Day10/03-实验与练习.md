# Day10 实验与练习：其他集合框架源码分析

> 完成日期：____年__月__日

---

## 实验 A：ArrayList vs LinkedList 性能对比

### 实验目标

通过实际代码测试 ArrayList 和 LinkedList 在不同操作场景下的性能差异，理解理论复杂度与实际性能的关系。

### 实验步骤

#### A1：尾部追加性能对比

```bash
cd Day10/code
javac LinkedListDemo.java && java LinkedListDemo
```

**测试内容**：向 ArrayList 和 LinkedList 分别追加 100 万个元素，记录耗时。

| 操作 | ArrayList 耗时 | LinkedList 耗时 | 胜者 |
|------|---------------|-----------------|------|
| 尾部追加 100 万元素 | | | |

**分析**：为什么 ArrayList 更快？

> 你的分析：

#### A2：头部插入性能对比

**测试内容**：在头部插入 10 万个元素。

| 操作 | ArrayList 耗时 | LinkedList 耗时 | 胜者 |
|------|---------------|-----------------|------|
| 头部插入 10 万元素 | | | |

**分析**：为什么 LinkedList 更快？

> 你的分析：

#### A3：随机访问性能对比

**测试内容**：在包含 10 万个元素的列表中随机访问 10 万次。

| 操作 | ArrayList 耗时 | LinkedList 耗时 | 胜者 |
|------|---------------|-----------------|------|
| 随机访问 10 万次 | | | |

**分析**：LinkedList 为什么慢了这么多？

> 你的分析：

#### A4：遍历性能对比

**测试内容**：使用 for-each 遍历 100 万元素。

| 操作 | ArrayList 耗时 | LinkedList 耗时 | 胜者 |
|------|---------------|-----------------|------|
| for-each 遍历 100 万 | | | |

**分析**：遍历时两者差距大吗？为什么？

> 你的分析：

### 验收标准

- [ ] 成功运行 LinkedListDemo.java
- [ ] 记录了每项测试的耗时数据
- [ ] 能解释每项测试结果背后的原因
- [ ] 理解了缓存友好性对实际性能的影响

---

## 实验 B：手写 ArrayList 和 LinkedList

### 实验目标

通过手写简化版的 ArrayList，深入理解其底层实现原理。

### 实验步骤

#### B1：阅读并理解 SimpleArrayList.java

```bash
cd Day10/code
javac SimpleArrayList.java && java SimpleArrayList
```

**需要理解的核心方法**：

- [ ] `add(E e)` — 扩容 + 添加
- [ ] `add(int index, E e)` — 指定位置插入 + 元素移动
- [ ] `remove(int index)` — 删除 + 元素移动
- [ ] `get(int index)` — 数组下标访问
- [ ] `grow()` — 1.5 倍扩容
- [ ] `iterator()` — 迭代器 + fail-fast

#### B2：手写增强功能

在 SimpleArrayList 的基础上，尝试添加以下功能：

- [ ] `contains(Object o)` 方法
- [ ] `indexOf(Object o)` 方法
- [ ] `removeIf(Predicate<E> filter)` 方法
- [ ] `toString()` 方法

#### B3：思考题

1. 为什么扩容使用 1.5 倍而不是 2 倍？
   > 你的回答：

2. 为什么 remove 后要将最后一个位置置为 null？
   > 你的回答：

3. fail-fast 是如何检测到并发修改的？
   > 你的回答：

### 验收标准

- [ ] SimpleArrayList 编译运行成功
- [ ] 理解了 add、remove、grow 的核心逻辑
- [ ] 完成了至少 2 个增强功能
- [ ] 回答了所有思考题

---

## 实验 C：LinkedHashMap 实现 LRU 缓存

### 实验目标

使用 LinkedHashMap 实现一个完整的 LRU 缓存，理解 accessOrder 和 removeEldestEntry 的工作原理。

### 实验步骤

#### C1：运行 LRUCacheDemo

```bash
cd Day10/code
javac LRUCacheDemo.java && java LRUCacheDemo
```

#### C2：观察 LRU 淘汰行为

依次执行以下操作，记录每步后缓存的状态（假设缓存容量为 3）：

| 操作 | 缓存状态（头→尾 = 最老→最新） | 被淘汰的元素 |
|------|------------------------------|-------------|
| put("A", 1) | | |
| put("B", 2) | | |
| put("C", 3) | | |
| get("A") | | |
| put("D", 4) | | |
| get("C") | | |
| put("E", 5) | | |

#### C3：思考题

1. 如果 `accessOrder = false`，put("D", 4) 时淘汰的是谁？为什么？
   > 你的回答：

2. LinkedHashMap 中 `afterNodeAccess` 方法的作用是什么？
   > 你的回答：

3. 为什么 LRU 缓存要继承 LinkedHashMap 而不是 HashMap？
   > 你的回答：

4. 如果需要一个线程安全的 LRU 缓存，你会怎么做？
   > 你的回答：

### 验收标准

- [ ] LRUCacheDemo 编译运行成功
- [ ] 正确记录了每步的缓存状态
- [ ] 理解了 accessOrder=true 时的 get/put 行为
- [ ] 回答了所有思考题
- [ ] （进阶）尝试实现了线程安全版本

---

## 实验 D：fail-fast 机制验证

### 实验目标

通过代码验证 fail-fast 机制的触发条件和安全的替代方案。

### 实验步骤

#### D1：触发 ConcurrentModificationException

在 ArrayListDemo.java 中有 fail-fast 演示代码，运行观察：

```bash
cd Day10/code
javac ArrayListDemo.java && java ArrayListDemo
```

#### D2：验证 fail-fast 触发场景

分别测试以下场景，记录结果：

| 场景 | 是否抛异常 | 原因 |
|------|-----------|------|
| for-each 中调用 list.remove() | | |
| Iterator 遍历中调用 list.add() | | |
| 使用 Iterator.remove() 删除 | | |
| 使用 list.removeIf() 删除 | | |
| 倒序 for 循环中 list.remove(i) | | |
| 使用 CopyOnWriteArrayList | | |

#### D3：单线程下的"假"安全

测试下面代码：

```java
List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));
for (String s : list) {
    if ("B".equals(s)) {
        list.remove(s);
    }
}
System.out.println(list);
```

这段代码会抛异常吗？为什么？

> 你的分析：

提示：尝试将 "B" 改为 "C"，再改为 "A"，观察不同的结果。

#### D4：多线程 fail-fast 验证

```java
List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C", "D", "E"));

// 线程1：遍历
new Thread(() -> {
    for (String s : list) {
        System.out.println("读取: " + s);
        try { Thread.sleep(100); } catch (Exception e) {}
    }
}).start();

// 线程2：修改
new Thread(() -> {
    try { Thread.sleep(150); } catch (Exception e) {}
    list.add("F");
    System.out.println("添加了 F");
}).start();
```

观察结果并记录：

> 你的观察：

### 验收标准

- [ ] 成功触发了 ConcurrentModificationException
- [ ] 记录了每个场景的测试结果
- [ ] 理解了 fail-fast 的检测原理（modCount 机制）
- [ ] 掌握了至少 3 种安全删除元素的方式
- [ ] 理解了"假安全"场景的原因

---

## 综合练习

### 练习 1：集合选型

为以下场景选择最合适的集合，并说明理由：

1. 存储用户浏览历史（需要保持顺序，可能有重复）
   > 你的选择和理由：

2. 存储网站访问过的 URL（需要去重，需要保持访问顺序）
   > 你的选择和理由：

3. 存储学生成绩排名（需要按分数排序，分数可能相同）
   > 你的选择和理由：

4. 实现一个任务调度器（按优先级执行任务）
   > 你的选择和理由：

5. 实现一个"撤销/重做"功能
   > 你的选择和理由：

### 练习 2：源码填空

不看源码，完成以下代码：

```java
// ArrayList 的 add 方法
public boolean add(E e) {
    // 1. 确保容量：____________________
    // 2. 赋值：________________________
    return true;
}

// ArrayList 的 grow 方法
private void grow(int minCapacity) {
    int oldCapacity = elementData.length;
    // 新容量计算：______________________
    elementData = ________________________;
}

// LinkedList 的 node(int index) 方法
Node<E> node(int index) {
    if (________________) {
        // 从 first 正向遍历
    } else {
        // 从 last 反向遍历
    }
}
```

### 练习 3：画图题

在纸上画出以下操作的过程：

1. ArrayList 初始容量 4，依次 add 5 个元素的扩容过程
2. LinkedList 的 add(2, "X") 插入操作（假设已有 A→B→C→D）
3. PriorityQueue 依次 offer 5, 3, 7, 1 后的堆结构
4. ArrayDeque 容量 8，head=6, tail=2 时 addFirst("X") 的过程

---

## 实验完成自检

| 实验 | 完成状态 | 主要收获 |
|------|---------|---------|
| 实验A：性能对比 | ⬜ 未完成 / ✅ 已完成 | |
| 实验B：手写 ArrayList | ⬜ 未完成 / ✅ 已完成 | |
| 实验C：LRU 缓存 | ⬜ 未完成 / ✅ 已完成 | |
| 实验D：fail-fast 验证 | ⬜ 未完成 / ✅ 已完成 | |
| 综合练习 | ⬜ 未完成 / ✅ 已完成 | |
