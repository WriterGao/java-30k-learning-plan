# Day10 学习笔记：其他集合框架源码分析

> 学习日期：____年__月__日
> 学习时长：__小时

---

## 一、Java 集合框架全景图

### 我的理解

<!-- 用自己的话描述 Collection 和 Map 两大体系的关系 -->

### Collection 体系关键类

| 接口/类 | 底层数据结构 | 特点 | 我的理解 |
|---------|-------------|------|----------|
| ArrayList | | | |
| LinkedList | | | |
| HashSet | | | |
| LinkedHashSet | | | |
| TreeSet | | | |
| PriorityQueue | | | |
| ArrayDeque | | | |

### Map 体系关键类

| 接口/类 | 底层数据结构 | 特点 | 我的理解 |
|---------|-------------|------|----------|
| HashMap | | | |
| LinkedHashMap | | | |
| TreeMap | | | |
| ConcurrentHashMap | | | |

---

## 二、ArrayList 源码分析

### 核心字段

```java
// 默认容量：
// 底层数组：
// size 字段：
```

### 扩容机制

- 无参构造初始容量是多少？
- 第一次 add 时扩容到多少？
- 扩容倍数是多少？怎么计算的？
- 扩容的核心方法是什么？

### add() 方法流程

<!-- 用自己的话描述 add(E e) 的完整流程 -->

1. 
2. 
3. 

### remove() 方法要点

<!-- 按索引删除和按对象删除的区别 -->

### fail-fast 机制

- modCount 的作用是什么？
- 什么时候会抛 ConcurrentModificationException？
- 如何在遍历时安全删除元素？（列举至少3种方式）

### subList 的坑

<!-- 记录 subList 的3个注意事项 -->

1. 
2. 
3. 

---

## 三、LinkedList 源码分析

### Node 节点结构

```java
// 画出 Node 的结构：
// item:
// prev:
// next:
```

### 与 ArrayList 的核心区别

<!-- 从时间复杂度、内存、缓存友好性等角度 -->

### node(int index) 的折半查找优化

<!-- 描述这个优化的原理 -->

### LinkedList 作为 Deque

<!-- 列出 LinkedList 作为 Deque 和 Stack 使用的方法映射 -->

---

## 四、ArrayList vs LinkedList 对比

### 我的总结表

| 对比维度 | ArrayList | LinkedList | 我选谁 |
|----------|-----------|------------|--------|
| 随机访问 | | | |
| 头部插入 | | | |
| 尾部追加 | | | |
| 中间插入 | | | |
| 内存占用 | | | |
| 缓存友好性 | | | |
| 遍历性能 | | | |

### 实际选择建议

<!-- 什么情况下用 ArrayList？什么情况下用 LinkedList？ -->

---

## 五、HashSet 源码分析

### HashSet 的本质

<!-- HashSet 底层是什么？value 用了什么？为什么？ -->

### PRESENT 对象的作用

<!-- 为什么不用 null 作为 value？ -->

---

## 六、LinkedHashMap / LinkedHashSet 源码分析

### LinkedHashMap 的数据结构

<!-- 在 HashMap 基础上增加了什么？ -->

### accessOrder 参数

- false（默认）：
- true：

### 三个钩子方法

| 方法 | 调用时机 | 作用 |
|------|---------|------|
| afterNodeAccess | | |
| afterNodeInsertion | | |
| afterNodeRemoval | | |

### LRU 缓存实现

```java
// 写出 LRU 缓存的核心代码：
```

**LRU 淘汰流程的理解**：

---

## 七、TreeMap / TreeSet 源码分析

### 红黑树的 5 条性质

1. 
2. 
3. 
4. 
5. 

### Comparable vs Comparator

| 对比项 | Comparable | Comparator |
|--------|-----------|------------|
| 包 | | |
| 方法 | | |
| 实现位置 | | |
| 使用场景 | | |

### NavigableMap 常用方法

<!-- 列出并解释 lowerKey/floorKey/ceilingKey/higherKey 等 -->

---

## 八、PriorityQueue 源码分析

### 二叉堆的数组表示

<!-- 父子节点索引关系公式 -->

- 父节点索引：
- 左子节点索引：
- 右子节点索引：

### offer() 上浮操作

<!-- 用自己的话描述上浮过程 -->

### poll() 下沉操作

<!-- 用自己的话描述下沉过程 -->

---

## 九、ArrayDeque 源码分析

### 循环数组原理

<!-- 描述 head/tail 指针如何实现循环 -->

### 位运算取模

<!-- 为什么数组长度必须是 2 的幂？位运算的优势？ -->

### 与 LinkedList 的对比

<!-- 为什么 ArrayDeque 更推荐？ -->

---

## 十、Collections 工具类

### 常用方法分类

**排序与变换**：

**查找与统计**：

**包装与视图**：

**工厂方法**：

### unmodifiableList 的注意事项

<!-- 它返回的是视图还是副本？修改原始 list 会怎样？ -->

### synchronizedList 的注意事项

<!-- 迭代器为什么需要手动同步？ -->

---

## 十一、集合选型

### 我的选型总结

| 需求场景 | 推荐集合 | 理由 |
|----------|----------|------|
| 普通列表 | | |
| 栈 | | |
| 队列 | | |
| 去重 | | |
| 有序去重 | | |
| 键值映射 | | |
| 有序映射 | | |
| LRU 缓存 | | |
| 优先级队列 | | |
| 多线程 Map | | |

---

## 十二、fail-fast vs fail-safe

### 对比总结

| 特性 | fail-fast | fail-safe |
|------|----------|-----------|
| 异常 | | |
| 检测机制 | | |
| 数据一致性 | | |
| 适用场景 | | |
| 代表集合 | | |

---

## 十三、今日收获与感悟

### 最大的收获

<!-- 今天学到的最重要的知识点 -->

### 还有疑问的地方

<!-- 记录下还不太理解的内容 -->

### 面试模拟

<!-- 尝试回答课件中的面试题，不看答案，用自己的话 -->

**Q1：ArrayList 的扩容机制？**

我的回答：

**Q2：ArrayList 和 LinkedList 的区别？**

我的回答：

**Q3：HashSet 如何保证不重复？**

我的回答：

**Q4：LinkedHashMap 如何实现 LRU？**

我的回答：

**Q5：fail-fast 和 fail-safe 的区别？**

我的回答：
