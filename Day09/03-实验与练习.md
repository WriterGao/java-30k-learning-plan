# Day09 实验与练习

> **参考课件**：`00-教学课件_ConcurrentHashMap源码深度分析.md`  
> **实验代码**：`code/` 目录

---

## 0. 环境准备

### 必需工具

- **JDK**：建议使用 JDK 8+
- **IDE 或文本编辑器**：用于查看和修改代码

### 编译代码

```bash
cd Day09/code
javac *.java
```

> **备注**：所有实验代码已提供在 `code/` 目录下，可直接编译运行。

---

## 1. 实验 A：ConcurrentHashMap vs HashMap 多线程安全性对比（必须完成）

### 实验目标

1. 验证 HashMap 在多线程下的数据丢失问题
2. 验证 ConcurrentHashMap 在多线程下的数据完整性
3. 对比 Hashtable / synchronizedMap / ConcurrentHashMap 的正确性
4. 理解为什么 HashMap 不能在多线程环境下使用

### 实验步骤

#### 步骤1：运行多线程安全性对比

```bash
java CHMvsHashMapDemo
```

#### 步骤2：观察 HashMap 不安全

**观察要点**：
- [ ] 多个线程各写入相同数量的条目，HashMap 的实际大小是否等于期望值
- [ ] 是否抛出异常（ArrayIndexOutOfBoundsException 或 ConcurrentModificationException）
- [ ] 多次运行，丢失的数据量是否每次不同（不确定性）

**记录**：
- 期望大小：________
- 实际大小：________
- 丢失条数：________
- 是否有异常：________

#### 步骤3：观察 ConcurrentHashMap 安全

**记录**：

| Map 类型 | 期望大小 | 实际大小 | 正确？ |
|----------|---------|---------|--------|
| HashMap | | | |
| Hashtable | | | |
| synchronizedMap | | | |
| ConcurrentHashMap | | | |

#### 步骤4：观察原子操作 vs 非原子操作

**记录**：
- 非原子 get + put 的 count 结果：________
- 原子 compute 的 count 结果：________
- 期望值：________
- 结论：________

### 思考题

1. **HashMap 在 JDK 7 中多线程扩容可能导致什么问题？在 JDK 8 中还会出现吗？**
   - 
2. **为什么 HashMap 的 put 会丢失数据？请描述具体的竞态条件。**
   - 
3. **ConcurrentHashMap 的空桶 CAS 和非空桶 synchronized 分别解决了什么问题？**
   - 

### 验收标准

- [ ] 能观察到 HashMap 在多线程下的数据丢失
- [ ] 能解释 HashMap 线程不安全的根因
- [ ] 三种线程安全 Map 均通过正确性验证
- [ ] 理解原子操作与非原子操作的区别

---

## 2. 实验 B：观察 ConcurrentHashMap 扩容过程（必须完成）

### 实验目标

1. 理解 ConcurrentHashMap 的扩容触发条件
2. 观察多线程协助扩容的现象
3. 理解 ForwardingNode 的作用
4. 理解弱一致性迭代器的行为

### 实验步骤

#### 步骤1：运行 ConcurrentHashMap 核心操作演示

```bash
java ConcurrentHashMapDemo
```

#### 步骤2：观察扩容过程

**观察要点**：
- [ ] sizeCtl 值的变化
- [ ] 扩容前后 table 的大小变化
- [ ] 并发写入时是否触发了多线程协助扩容

**记录**：
- 初始容量：________
- 扩容触发时的元素数量：________
- 扩容后的容量：________

#### 步骤3：观察弱一致性迭代器

**记录**：

| Map 类型 | 迭代时修改 | 是否抛异常 | 迭代器类型 |
|----------|----------|----------|----------|
| ConcurrentHashMap | 添加/删除元素 | | 弱一致性 |
| HashMap | 添加元素 | | fail-fast |

#### 步骤4：观察 size() 的行为

**记录**：
- 并发写入过程中 size() 是否每次递增：________
- 最终 size() 是否正确：________
- mappingCount() 与 size() 的区别：________

### 思考题

1. **ConcurrentHashMap 的弱一致性迭代器有什么利弊？**
   - 优点：
   - 缺点：
2. **ForwardingNode 有哪三个作用？**
   - 
3. **多线程协助扩容时，任务是如何分配的？（stride 和 transferIndex）**
   - 

### 验收标准

- [ ] 理解扩容的触发条件和过程
- [ ] 理解 ForwardingNode 的作用
- [ ] 理解弱一致性迭代器的行为
- [ ] 能区分 fail-fast 和弱一致性迭代器

---

## 3. 实验 C：性能对比测试（必须完成）

### 实验目标

1. 量化 ConcurrentHashMap 与 Hashtable / synchronizedMap 的性能差异
2. 分析不同线程数下的性能变化趋势
3. 分析读写比例对性能的影响
4. 总结 ConcurrentHashMap 高性能的原因

### 实验步骤

#### 步骤1：运行性能对比测试

```bash
java CHMPerformanceDemo
```

> **注意**：测试可能需要几分钟时间，请耐心等待。

#### 步骤2：记录纯写入性能

| 线程数 | Hashtable(ms) | synchronizedMap(ms) | ConcurrentHashMap(ms) | 加速比 |
|--------|--------------|--------------------|-----------------------|--------|
| 1 | | | | |
| 4 | | | | |
| 8 | | | | |
| 16 | | | | |
| 32 | | | | |

#### 步骤3：记录纯读取性能

| 线程数 | Hashtable(ms) | synchronizedMap(ms) | ConcurrentHashMap(ms) | 加速比 |
|--------|--------------|--------------------|-----------------------|--------|
| 1 | | | | |
| 4 | | | | |
| 8 | | | | |
| 16 | | | | |
| 32 | | | | |

#### 步骤4：记录混合读写性能（80% 读 + 20% 写）

| 线程数 | Hashtable(ms) | synchronizedMap(ms) | ConcurrentHashMap(ms) | 加速比 |
|--------|--------------|--------------------|-----------------------|--------|
| 1 | | | | |
| 4 | | | | |
| 8 | | | | |
| 16 | | | | |
| 32 | | | | |

#### 步骤5：分析结果

- 纯写入时，ConcurrentHashMap 相比 Hashtable 的最大加速比：________
- 纯读取时，ConcurrentHashMap 相比 Hashtable 的最大加速比：________
- 混合读写时，ConcurrentHashMap 相比 Hashtable 的最大加速比：________
- 哪种场景下 ConcurrentHashMap 优势最大？为什么？
  - 
- 单线程下，ConcurrentHashMap 与 Hashtable 性能差异如何？
  - 

### 思考题

1. **ConcurrentHashMap 的 get 为什么不需要加锁？靠什么保证可见性？**
   - 
2. **为什么 ConcurrentHashMap 在纯读取场景下优势最大？**
   - 
3. **线程数超过 CPU 核心数后，性能是否会继续提升？为什么？**
   - 
4. **在什么场景下，Hashtable 的性能可能接近 ConcurrentHashMap？**
   - 

### 验收标准

- [ ] 能量化三种 Map 在不同场景下的性能差异
- [ ] 理解 ConcurrentHashMap 高性能的核心原因（CAS + 细粒度锁 + 无锁读取）
- [ ] 能分析线程数与性能的关系
- [ ] 能根据场景选择合适的 Map 实现

---

## 4. 实验 D：复合操作陷阱演示（必须完成）

### 实验目标

1. 理解 ConcurrentHashMap 的"复合操作非原子"陷阱
2. 掌握正确的并发操作方式（compute / merge / putIfAbsent）
3. 理解 size() 在并发下的近似特性
4. 理解 ConcurrentHashMap 不允许 null 的原因

### 实验步骤

#### 步骤1：运行 ConcurrentHashMapDemo

```bash
java ConcurrentHashMapDemo
```

#### 步骤2：观察复合操作陷阱

**记录**：

| 操作方式 | 期望结果 | 实际结果 | 正确？ | 原因 |
|---------|---------|---------|--------|------|
| get + put（非原子） | | | | |
| compute（原子） | | | | |
| merge（原子） | | | | |
| putIfAbsent | | | | |

#### 步骤3：验证 null 限制

**记录**：
- put(null, value) 是否抛异常：________
- put(key, null) 是否抛异常：________
- 异常类型：________

#### 步骤4：观察 JDK 8 原子操作 API

**记录**：

| API | 作用 | 线程安全？ | 适用场景 |
|-----|------|----------|---------|
| putIfAbsent | | | |
| compute | | | |
| computeIfAbsent | | | |
| merge | | | |
| getOrDefault | | | |
| forEach(parallelism, action) | | | |
| search(parallelism, func) | | | |
| reduce(parallelism, transformer, reducer) | | | |

### 扩展实验（选做）

#### 扩展1：用 ConcurrentHashMap 实现线程安全的词频统计器

```java
ConcurrentHashMap<String, LongAdder> wordCount = new ConcurrentHashMap<>();

// 方式1：computeIfAbsent + increment
wordCount.computeIfAbsent(word, k -> new LongAdder()).increment();

// 方式2：merge
ConcurrentHashMap<String, Long> wordCount2 = new ConcurrentHashMap<>();
wordCount2.merge(word, 1L, Long::sum);

// 对比两种方式的性能和易用性
```

#### 扩展2：测试 computeIfAbsent 的递归死锁

```java
// 警告：以下代码可能导致死锁，仅供学习！
ConcurrentHashMap<Integer, Integer> map = new ConcurrentHashMap<>();
// 当 hash 冲突时，在 computeIfAbsent 中操作同 map 可能死锁
// map.computeIfAbsent(key, k -> { map.put(anotherKey, 42); return 1; });
```

### 思考题

1. **为什么 get() + put() 不是线程安全的复合操作？请画出时序图。**
   - 
2. **compute 与 put 的区别是什么？为什么 compute 更适合并发场景？**
   - 
3. **ConcurrentHashMap 不允许 null 的根本原因是什么？（不只是"因为设计如此"）**
   - 
4. **并行批量操作的 parallelismThreshold 参数如何选择？**
   - 

### 验收标准

- [ ] 能识别并避免"复合操作非原子"陷阱
- [ ] 能正确使用 compute / merge / putIfAbsent
- [ ] 理解为什么不允许 null
- [ ] 理解原子操作 API 与普通 put 的区别

---

## 5. 综合验收

完成所有实验后，回答以下综合问题：

### 5.1 知识串联

1. **从 HashMap → Hashtable → ConcurrentHashMap 的演进路线是什么？每次改进解决了什么问题？**
   - 

2. **ConcurrentHashMap JDK 7 → JDK 8 的核心改进有哪些？为什么要做这些改进？**
   - 

3. **ConcurrentHashMap 的 put/get/size 分别用了什么并发技术？为什么选择这些技术？**
   - put：
   - get：
   - size：

### 5.2 实验总结

| 实验 | 完成情况 | 关键收获 |
|------|---------|---------|
| A: ConcurrentHashMap vs HashMap 安全性 | [ ] 完成 | |
| B: 扩容过程观察 | [ ] 完成 | |
| C: 性能对比测试 | [ ] 完成 | |
| D: 复合操作陷阱 | [ ] 完成 | |

### 5.3 面试模拟

请用 5 分钟时间，模拟回答以下面试题：

> **面试官**：请你详细讲一下 ConcurrentHashMap 在 JDK 8 中的实现原理，包括 put、get、扩容的过程。

你的回答：

```
（在此写下你的回答）
```

---

> **提示**：完成所有实验后，请在 `02-学习笔记.md` 中记录你的实验结果和思考。
