# Day09 学习笔记

> **学习目标**：今天的笔记目标是"**能复述、能画图、能用代码验证**"，不要抄书。  
> **参考课件**：`00-教学课件_ConcurrentHashMap源码深度分析.md`

---

## 1. 为什么需要 ConcurrentHashMap

### 1.1 HashMap 线程不安全的根因

请用自己的话描述 HashMap 在多线程下的问题：

- **JDK 7 扩容死链**：
- **JDK 8 数据覆盖**：
- **put 的竞态条件**：
- **size 不准确**：

### 1.2 Hashtable 的问题

- **锁粒度**：
- **所有方法都加 synchronized**：
- **为什么性能差**：
- **读操作也需要锁**：

### 1.3 Collections.synchronizedMap 的问题

- **实现原理**：
- **与 Hashtable 的区别**：
- **复合操作不安全**（举例说明）：

---

## 2. JDK 7 ConcurrentHashMap（Segment 分段锁）

### 2.1 数据结构

请画出 JDK 7 ConcurrentHashMap 的数据结构图：

```
（在此画图：Segment[] + HashEntry[] + 链表）
```

- **Segment 是什么**：
- **Segment 继承什么**：
- **HashEntry 是什么**：
- **默认并发度**：
- **Segment 数量确定后能否扩容**：

### 2.2 put 流程

请用自己的话描述 JDK 7 的 put 流程：

1. 
2. 
3. 
4. 
5. 

### 2.3 get 流程

- **get 需要加锁吗**：
- **为什么不需要**：
- **volatile 的作用**：

### 2.4 size() 流程

请描述 size() 的"先乐观后悲观"策略：

1. 
2. 
3. 

### 2.5 scanAndLockForPut 的巧妙设计

- **自旋时做了什么优化**：
- **什么时候退化为阻塞**：

---

## 3. JDK 8 ConcurrentHashMap（CAS + synchronized）

### 3.1 数据结构

请画出 JDK 8 ConcurrentHashMap 的数据结构图：

```
（在此画图：Node[] + 链表 + 红黑树 + ForwardingNode + TreeBin）
```

### 3.2 核心字段

请解释以下核心字段的含义：

- **table**：
- **nextTable**：
- **sizeCtl**：
  - = 0 时表示：
  - > 0 时表示（分两种情况）：
  - = -1 时表示：
  - < -1 时表示：
- **baseCount**：
- **counterCells**：
- **transferIndex**：
- **cellsBusy**：

### 3.3 特殊节点类型

| 节点类型 | hash 值 | 含义 | 作用 |
|---------|--------|------|------|
| Node | >= 0 | | |
| ForwardingNode | -1 (MOVED) | | |
| TreeBin | -2 (TREEBIN) | | |

### 3.4 spread() vs HashMap.hash()

- **相同点**：
- **不同点（& HASH_BITS）**：
- **为什么 hash 必须非负**：

### 3.5 initTable() 分析

请用自己的话描述 initTable() 的并发控制：

- **CAS 的作用**：
- **sizeCtl = -1 的含义**：
- **Thread.yield() 的作用**：
- **双重检查的原因**：

### 3.6 put() 源码分析

请用自己的话逐步描述 put() 的执行流程：

1. **null 检查**：
2. **spread(hash)**：
3. **分支1 - table == null**：
4. **分支2 - 桶为空（CAS 写入）**：
5. **分支3 - 桶的 hash == MOVED**：
6. **分支4 - 桶不为空（synchronized 锁头节点）**：
   - 双重检查的原因：
   - 链表处理：
   - 红黑树处理：
7. **binCount >= TREEIFY_THRESHOLD**：
8. **addCount**：

### 3.7 get() 源码分析

请用自己的话描述 get() 为什么不需要加锁：

- **Node.val 和 Node.next 是 volatile 的**：
- **tabAt() 使用 volatile 读**：
- **遇到 ForwardingNode 的处理**：
- **遇到 TreeBin 的处理**：
- **整个过程无锁的安全保障**：

### 3.8 扩容 transfer()

请描述多线程协助扩容的过程：

1. **触发条件**：
2. **stride（步长）的计算**：
3. **transferIndex 的作用**：
4. **ForwardingNode 的三个作用**：
   a. 
   b. 
   c. 
5. **数据迁移过程（链表拆分）**：
6. **任务领取方式（CAS transferIndex）**：
7. **如何判断扩容完成（sizeCtl 低16位）**：

### 3.9 size() / sumCount()

- **baseCount 的作用**：
- **counterCells 的作用**：
- **与 LongAdder 的关系**：
- **@Contended 避免伪共享**：
- **为什么 size() 不精确**：
- **mappingCount() 与 size() 的区别**：

### 3.10 TreeBin 的读写锁设计

- **为什么桶头放 TreeBin 而不是 TreeNode**：
- **lockState 的三个状态（WRITER/WAITER/READER）**：
- **有写锁时读操作如何处理**：
- **为什么这样设计**：

---

## 4. JDK 7 vs JDK 8 对比

### 4.1 对比表格

| 维度 | JDK 7 | JDK 8 |
|------|-------|-------|
| 数据结构 | | |
| 锁粒度 | | |
| 锁实现 | | |
| 默认并发度 | | |
| 空桶写入 | | |
| 链表过长 | | |
| 扩容方式 | | |
| 扩容协助 | | |
| 计数方式 | | |
| hash 算法 | | |

### 4.2 为什么 JDK 8 放弃了 Segment

请用自己的话解释（至少 3 个原因）：

1. 
2. 
3. 

### 4.3 为什么 JDK 8 用 synchronized 而不是 ReentrantLock

请用自己的话解释（至少 3 个原因）：

1. 
2. 
3. 

---

## 5. ConcurrentHashMap vs HashMap vs Hashtable 对比

### 5.1 全面对比表格

| 维度 | HashMap | Hashtable | ConcurrentHashMap |
|------|---------|-----------|-------------------|
| 线程安全 | | | |
| null key/value | | | |
| 锁粒度 | | | |
| 读操作 | | | |
| 迭代器 | | | |
| 继承关系 | | | |
| 性能（单线程） | | | |
| 性能（多线程） | | | |
| 推荐使用 | | | |

### 5.2 null 不允许的原因

请用自己的话解释 ConcurrentHashMap 不允许 null 的原因：

- **二义性问题**：
- **并发环境下的困境**：

---

## 6. 常见使用陷阱

### 6.1 复合操作非原子

请举例说明并给出正确写法：

```java
// 错误写法：

// 正确写法：
```

### 6.2 size() 不精确

- **原因**：
- **应对策略**：

### 6.3 computeIfAbsent 中的递归死锁

- **原因**：
- **规避方法**：

---

## 7. 实验观察

### 7.1 实验A：ConcurrentHashMap vs HashMap 多线程安全性

运行 `code/CHMvsHashMapDemo.java` 后记录结果：

**HashMap 多线程写入**：
- 期望大小：________
- 实际大小：________
- 丢失数据条数：________

**ConcurrentHashMap 多线程写入**：
- 期望大小：________
- 实际大小：________
- 是否正确：________

### 7.2 实验B：扩容过程观察

运行 `code/ConcurrentHashMapDemo.java` 后记录：

- 是否观察到多线程协助扩容：________
- ForwardingNode 的作用：________

### 7.3 实验C：性能对比

运行 `code/CHMPerformanceDemo.java` 后记录：

| Map 类型 | 写入时间(ms) | 读取时间(ms) | 混合读写(ms) |
|----------|------------|------------|------------|
| Hashtable | | | |
| synchronizedMap | | | |
| ConcurrentHashMap | | | |

你的观察和结论：
- 

### 7.4 实验D：复合操作陷阱

运行 `code/ConcurrentHashMapDemo.java` 的陷阱演示后记录：

- 非原子复合操作的结果：________
- 原子操作（compute）的结果：________
- 差异原因：________

---

## 8. 5 分钟复述稿（面试式）

用 5 分钟讲清楚"ConcurrentHashMap 源码分析"，要求：
- 先总览，再逐一解释，再给关键实现细节

**我的复述稿**：

```
【为什么需要 ConcurrentHashMap】
HashMap 线程不安全（JDK7 扩容死链、JDK8 数据覆盖）...
Hashtable 全表锁性能差...

【JDK 7 实现】
Segment 分段锁，默认16个 Segment...
Segment 继承 ReentrantLock...
put 先定位 Segment 再 lock...
get 无锁（volatile）...
size() 先乐观（不加锁尝试2次）后悲观（加全锁）...

【JDK 8 实现 — 重点】
Node[] + 链表 + 红黑树...
放弃 Segment，改用 CAS + synchronized(桶头节点)...

put 流程：
  1. table为空 → initTable (CAS sizeCtl=-1)
  2. 桶为空 → CAS 放入（无锁！）
  3. 正在扩容(MOVED) → helpTransfer
  4. 桶不为空 → synchronized(桶头) → 链表尾插 / 红黑树
  5. addCount → 检查扩容

get: 完全无锁，volatile 保证可见性
  遇到 ForwardingNode → 去新表找

transfer 多线程协助扩容:
  - stride 分配任务（从后往前）
  - transferIndex CAS 领取
  - ForwardingNode 标记已迁移
  - synchronized 迁移每个桶
  - 最后一个线程完成收尾

size 使用 baseCount + counterCells（LongAdder 思想）

sizeCtl 的多重含义:
  0=未初始化, >0=阈值, -1=初始化中, <-1=扩容中(低16位=线程数)

【核心改进】
JDK8 锁粒度从 Segment 细化到单个桶...
并发度从16提升到桶数量...
引入红黑树 + 多线程扩容 + LongAdder计数...

【面试亮点】
null 不允许（二义性问题 + 并发困境）
弱一致性迭代器（不抛 CME）
TreeBin 的读写锁设计
ForwardingNode 的三重作用
```

---

## 9. 学习总结与疑问

### 9.1 今天学到的核心知识点

1. 
2. 
3. 
4. 
5. 

### 9.2 还有疑问的地方

1. 
2. 

### 9.3 下一步学习计划

- [ ] 用 IDE debug 跟踪 ConcurrentHashMap.putVal() 源码
- [ ] 用 IDE debug 跟踪 transfer() 扩容源码
- [ ] 阅读 LongAdder 源码，对比 counterCells 的实现
- [ ] 准备下一天的学习

---

> **提示**：完成笔记后，对照课件最后的总结进行自我验收。
