# Day11 实验与练习

> **实验目标**：通过动手编码验证设计模式创建型模式的核心概念  
> **参考课件**：`00-教学课件_设计模式之创建型模式详解.md`  
> **实验代码**：`code/` 目录

---

## 实验A：实现并对比 6 种单例模式

### 实验目标

1. 手写 6 种单例实现（饿汉式×2、懒汉式×3、静态内部类、枚举）
2. 验证各实现方式的线程安全性
3. 验证反射和序列化对单例的破坏
4. 理解 volatile 在 DCL 中的作用

### 实验步骤

#### Step 1：运行单例模式演示

```bash
cd Day11/code
javac SingletonDemo.java
java SingletonDemo
```

#### Step 2：观察输出

**观察要点**：
- 每种单例实现方式在多线程下是否返回同一实例（hashCode 是否一致）
- 线程不安全的懒汉式在高并发下是否创建了多个实例
- 反射攻击是否成功破坏了单例
- 枚举单例是否成功防御了反射攻击
- 序列化/反序列化后是否仍然是同一实例
- readResolve() 是否成功防御了序列化破坏

#### Step 3：自己动手

请尝试**不看代码**，手写以下实现：

1. DCL 双重检查锁单例（注意 volatile）
2. 静态内部类单例
3. 枚举单例

#### Step 4：思考题

1. 为什么 DCL 不加 volatile 可能出问题？请画出指令重排序的时序图。
2. 如果一个单例类需要实现 Serializable，应该怎么做？
3. Spring 的 @Scope("singleton") 和我们手写的单例有什么区别？

### 验收标准

- [ ] 能说出 6 种单例实现的优缺点
- [ ] 能解释 DCL 中 volatile 的作用
- [ ] 能手写 DCL 和静态内部类单例
- [ ] 理解反射和序列化破坏单例的原理及防御方案

---

## 实验B：用工厂模式重构 if-else 代码

### 实验目标

1. 体验三种工厂模式的区别
2. 理解工厂模式如何遵循开闭原则
3. 能将 if-else 代码重构为工厂模式

### 实验步骤

#### Step 1：运行工厂模式演示

```bash
cd Day11/code
javac FactoryDemo.java
java FactoryDemo
```

#### Step 2：观察输出

**观察要点**：
- 简单工厂如何通过一个工厂类创建不同产品
- 工厂方法如何通过子类工厂创建产品
- 抽象工厂如何创建一整个产品族
- 对比三种工厂模式在新增产品时的扩展方式

#### Step 3：重构练习

请将以下 if-else 代码重构为工厂模式：

```java
// 原始代码（违反开闭原则）
public class NotificationService {
    public void send(String type, String message) {
        if ("email".equals(type)) {
            System.out.println("发送邮件: " + message);
        } else if ("sms".equals(type)) {
            System.out.println("发送短信: " + message);
        } else if ("wechat".equals(type)) {
            System.out.println("发送微信: " + message);
        }
    }
}
```

请分别用以下方式重构：
1. 简单工厂模式
2. 工厂方法模式
3. （选做）如果同时需要不同平台（国内/海外）的通知渠道，用抽象工厂模式

#### Step 4：思考题

1. 如果产品种类很少（2-3 种）且不会变化，是否需要用工厂模式？
2. 简单工厂和工厂方法的核心区别是什么？（一句话概括）
3. 什么情况下用抽象工厂？什么是"产品族"？

### 验收标准

- [ ] 能运行三种工厂模式的 Demo
- [ ] 能将 if-else 代码重构为简单工厂和工厂方法
- [ ] 能说清楚三种工厂的区别和适用场景
- [ ] 理解抽象工厂的"产品族"概念

---

## 实验C：用建造者模式构建复杂对象

### 实验目标

1. 理解建造者模式解决的问题（构造器参数爆炸）
2. 掌握经典建造者和链式建造者两种实现
3. 理解建造者模式与工厂模式的区别

### 实验步骤

#### Step 1：运行建造者模式演示

```bash
cd Day11/code
javac BuilderDemo.java
java BuilderDemo
```

#### Step 2：观察输出

**观察要点**：
- 经典建造者（Director + Builder）如何分步骤构建对象
- 链式建造者如何通过链式调用提升可读性
- 构建出来的对象是否是不可变的（final 字段）

#### Step 3：自己动手

请用链式建造者模式实现一个 `HttpRequest` 类：

```java
// 预期使用方式
HttpRequest request = new HttpRequest.Builder("GET", "https://api.example.com")
        .header("Authorization", "Bearer token")
        .header("Content-Type", "application/json")
        .timeout(5000)
        .body("{\"name\":\"test\"}")
        .build();
```

要求：
- `method` 和 `url` 是必需参数
- `headers`、`timeout`、`body` 是可选参数
- 构建完成后的对象应该是不可变的

#### Step 4：思考题

1. 建造者模式适合什么场景？不适合什么场景？
2. 如果对象只有 2-3 个参数，是否需要用建造者模式？
3. Lombok 的 @Builder 注解生成的代码和我们手写的有什么区别？

### 验收标准

- [ ] 能运行 BuilderDemo
- [ ] 能手写链式建造者模式
- [ ] 能说清楚建造者和工厂模式的区别
- [ ] 理解建造者模式的适用场景

---

## 实验D：深拷贝 vs 浅拷贝验证

### 实验目标

1. 理解浅拷贝和深拷贝的区别
2. 验证浅拷贝的"共享引用"问题
3. 掌握三种深拷贝实现方式

### 实验步骤

#### Step 1：运行原型模式演示

```bash
cd Day11/code
javac PrototypeDemo.java
java PrototypeDemo
```

#### Step 2：观察输出

**观察要点**：
- 浅拷贝后，修改克隆对象的引用类型字段是否会影响原对象
- 深拷贝后，修改克隆对象的引用类型字段是否会影响原对象
- 三种深拷贝方式（重写clone/序列化/JSON模拟）的区别
- 基本类型字段和引用类型字段在拷贝时的不同行为

#### Step 3：自己动手

请创建以下类并实现深拷贝：

```java
public class Department {
    private String name;
    private List<Employee> employees; // 引用类型
}

public class Employee {
    private String name;
    private int age;
}
```

要求：
1. 先实现浅拷贝，验证修改 employees 列表会影响原对象
2. 用三种方式实现深拷贝，验证修改 employees 列表不会影响原对象

#### Step 4：思考题

1. `String` 类型在浅拷贝时会有共享问题吗？为什么？
2. `ArrayList.clone()` 是浅拷贝还是深拷贝？
3. 什么时候选择重写 clone() 实现深拷贝？什么时候选择序列化？

### 验收标准

- [ ] 能运行 PrototypeDemo
- [ ] 能画图解释浅拷贝和深拷贝的区别
- [ ] 能用至少两种方式实现深拷贝
- [ ] 理解 String 的不可变性为什么不会受浅拷贝影响

---

## 综合练习（选做）

### 练习1：设计模式识别

以下代码分别使用了什么设计模式？

```java
// 代码A
Runtime runtime = Runtime.getRuntime();
```

```java
// 代码B
Calendar calendar = Calendar.getInstance();
```

```java
// 代码C
StringBuilder sb = new StringBuilder()
    .append("Hello")
    .append(" ")
    .append("World");
```

```java
// 代码D
ArrayList<String> list1 = new ArrayList<>(Arrays.asList("a", "b", "c"));
ArrayList<String> list2 = (ArrayList<String>) list1.clone();
```

### 练习2：模式选择

以下场景应该使用什么创建型模式？

1. 全局配置管理器，整个系统只需要一份配置
2. 根据不同消息类型（邮件/短信/推送）发送通知
3. 构建一个有 10+ 个可选参数的复杂查询条件
4. 批量创建 10000 个属性相似的游戏角色对象
5. 跨数据库的数据访问层，需要同时创建连接、命令、事务对象

### 练习3：Spring 中的设计模式

在你的 Spring 项目中找到以下设计模式的应用：

1. 单例模式：`@Service` / `@Component` 注解的 Bean
2. 工厂模式：`BeanFactory` / `FactoryBean`
3. 建造者模式：`ResponseEntity.ok().body(...)` 
4. 原型模式：`@Scope("prototype")`

---

## 本日实验总结

完成实验后，请填写：

| 实验 | 完成状态 | 最大收获 | 遇到的问题 |
|------|---------|---------|-----------|
| 实验A：单例模式 | | | |
| 实验B：工厂模式 | | | |
| 实验C：建造者模式 | | | |
| 实验D：原型模式 | | | |
