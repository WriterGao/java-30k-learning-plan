# Day05 实验与练习

> **参考课件**：`00-教学课件_CAS与AQS原理详解.md`  
> **实验代码**：`code/` 目录

---

## 0. 环境准备

### 必需工具

- **JDK**：建议使用 JDK 8+ （LongAdder、StampedLock 需要 JDK 8）
- **IDE 或文本编辑器**：用于查看和修改代码

### 编译代码

```bash
cd Day05/code
javac *.java
```

> **备注**：所有实验代码已提供在 `code/` 目录下，可直接编译运行。

---

## 1. 实验 A：CAS 操作与 ABA 问题复现（必须完成）

### 实验目标

1. 理解 CAS 的基本操作（compareAndSet 成功/失败）
2. 理解多线程下 CAS 保证原子性的原理
3. 复现 ABA 问题
4. 使用 AtomicStampedReference 解决 ABA 问题

### 实验步骤

#### 步骤1：运行 CAS 基本操作

```bash
java CASDemo
```

**观察要点**：
- [ ] compareAndSet 在期望值匹配时返回 true
- [ ] compareAndSet 在期望值不匹配时返回 false
- [ ] 多线程下 AtomicInteger 始终正确，普通 int 可能丢失更新

**记录**：
- 20个线程各执行10000次，普通int最终值：________（期望值 200000）
- 20个线程各执行10000次，AtomicInteger最终值：________
- 差值（丢失的更新数）：________

#### 步骤2：运行 ABA 问题演示

```bash
java ABADemo
```

**观察要点**：
- [ ] 普通 AtomicReference 无法检测 A→B→A 的变化，CAS 仍然成功
- [ ] AtomicStampedReference 通过版本号检测到变化，CAS 失败
- [ ] AtomicMarkableReference 通过标记位检测到变化，CAS 失败

**记录**：
- ABA 场景下 AtomicReference 的 CAS 结果：________ （成功/失败）
- ABA 场景下 AtomicStampedReference 的 CAS 结果：________ （成功/失败）
- ABA 场景下 AtomicMarkableReference 的 CAS 结果：________ （成功/失败）

### 思考题

1. **在什么业务场景下 ABA 问题会造成真正的危害？**
   - 
2. **为什么 AtomicStampedReference 使用 int 作为版本号而不是 long？**
   - 
3. **如果自旋次数过多，有哪些优化策略？**
   - 

### 验收标准

- [ ] 能用代码演示 CAS 的成功和失败
- [ ] 能复现 ABA 问题
- [ ] 能用 AtomicStampedReference 解决 ABA 问题
- [ ] 能解释 CAS 的底层实现原理

---

## 2. 实验 B：手写一个基于 AQS 的自定义锁（必须完成）

### 实验目标

1. 理解 AQS 的模板方法模式
2. 实现自定义的独占锁
3. 验证自定义锁的正确性
4. 理解 AQS 的 acquire/release 流程

### 实验步骤

#### 步骤1：阅读 CustomLock.java 源码

在运行之前，先**仔细阅读**代码中的注释，理解：

- [ ] Sync 内部类继承了 AQS
- [ ] tryAcquire：CAS 将 state 从 0 改为 1
- [ ] tryRelease：将 state 设回 0
- [ ] isHeldExclusively：判断是否当前线程独占

#### 步骤2：运行自定义锁测试

```bash
java CustomLock
```

**观察要点**：
- [ ] 测试1：10线程各执行10000次，计数器结果正确
- [ ] 测试2：tryLock 在锁被占用时立即返回 false
- [ ] 测试3：Condition 条件等待与唤醒正常工作
- [ ] 测试4：多线程按顺序获取和释放锁

**记录**：

| 测试 | 期望结果 | 实际结果 | 通过？ |
|------|---------|---------|--------|
| 基本 lock/unlock | 计数器=100000 | | |
| tryLock 非阻塞 | 返回 false | | |
| Condition 等待/唤醒 | 消费者被正确唤醒 | | |
| 多线程排队 | 线程依次获取锁 | | |

#### 步骤3：扩展练习（选做）

尝试修改 CustomLock，使其**支持可重入**：

提示：
1. tryAcquire 中检查当前线程是否已持有锁
2. 如果是同一线程，state + 1
3. tryRelease 中 state - 1，为 0 时完全释放

```java
// 你的可重入锁实现（参考 ReentrantLock 的 nonfairTryAcquire）
@Override
protected boolean tryAcquire(int acquires) {
    Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        // TODO: CAS 获取
    } else if (current == getExclusiveOwnerThread()) {
        // TODO: 可重入
    }
    return false;
}
```

### 思考题

1. **为什么 AQS 使用模板方法模式？子类只需要实现哪些方法？**
   - 
2. **CLH 队列中，为什么只有前驱是 head 的节点才尝试获取锁？**
   - 
3. **为什么 tryRelease 中不需要 CAS 而直接 setState？**
   - 
4. **如果不调用 unlock()，会发生什么？**
   - 

### 验收标准

- [ ] 自定义锁能正确保护临界区（计数器结果正确）
- [ ] 理解 tryAcquire/tryRelease 的实现逻辑
- [ ] 理解 AQS acquire/release 的完整调用链
- [ ] 能用语言描述 CLH 队列的入队和出队过程

---

## 3. 实验 C：ReentrantLock 公平锁 vs 非公平锁性能对比（必须完成）

### 实验目标

1. 观察公平锁和非公平锁的获取顺序差异
2. 对比两种模式的性能差异
3. 理解可重入特性
4. 掌握 Condition 精确唤醒

### 实验步骤

#### 步骤1：运行 ReentrantLock 演示

```bash
java ReentrantLockDemo
```

#### 步骤2：观察公平性

**记录获取顺序**：
- 非公平锁获取顺序：________
- 公平锁获取顺序：________
- 公平锁是否严格 FIFO？：________

#### 步骤3：记录性能数据

| 指标 | 非公平锁 | 公平锁 |
|------|---------|--------|
| 10线程×10万次 耗时(ms) | | |
| 性能比（公平/非公平） | | |

**分析**：为什么非公平锁通常更快？
- 

#### 步骤4：观察可重入

**记录**：
- 第1次获取锁后 holdCount = ________
- 第2次获取锁后 holdCount = ________
- 第3次获取锁后 holdCount = ________
- 释放1次后 holdCount = ________

#### 步骤5：观察 Condition 精确唤醒

**记录**：
- 输出是否为 "ABCABCABC"：________
- Condition 比 wait/notify 的优势是什么？
  - 

#### 步骤6：观察读写锁

**记录**：
- 多个读线程是否同时持有读锁？：________
- 读锁数量 getReadLockCount 最大值：________
- 写线程是否需要等待所有读锁释放？：________

### 扩展实验（选做）

尝试调整参数观察不同情况：

```java
// 修改线程数和循环次数
final int THREAD_COUNT = 50;    // 增加线程数
final int LOOP_COUNT = 500_000; // 增加循环次数
```

记录不同参数下的性能对比：

| 线程数 × 循环次数 | 非公平锁(ms) | 公平锁(ms) | 比值 |
|-------------------|-------------|-----------|------|
| 10 × 100,000 | | | |
| 20 × 100,000 | | | |
| 50 × 100,000 | | | |
| 10 × 500,000 | | | |

### 思考题

1. **非公平锁的"插队"发生在什么时刻？**
   - 
2. **公平锁的 hasQueuedPredecessors() 做了什么检查？**
   - 
3. **为什么 JDK 选择非公平锁作为默认实现？**
   - 
4. **ReentrantLock 什么时候应该用公平锁？**
   - 

### 验收标准

- [ ] 能观察到公平锁的 FIFO 顺序
- [ ] 能观察到非公平锁的插队现象
- [ ] 能量化两者的性能差异
- [ ] 理解 Condition 精确唤醒的实现

---

## 4. 实验 D：LongAdder vs AtomicLong 高并发性能对比（必须完成）

### 实验目标

1. 量化 LongAdder 和 AtomicLong 在不同并发度下的性能差异
2. 理解 LongAdder 分段思想的优势
3. 理解 LongAccumulator 的使用
4. 分析性能差异与线程数的关系

### 实验步骤

#### 步骤1：运行性能对比

```bash
java LongAdderVsAtomicDemo
```

#### 步骤2：记录基本用法

确认以下 API 的使用：
- [ ] `AtomicLong.incrementAndGet()`
- [ ] `LongAdder.increment()` / `LongAdder.sum()`
- [ ] `LongAccumulator.accumulate()` / `LongAccumulator.get()`

#### 步骤3：记录性能数据

| 线程数 | AtomicLong(ms) | LongAdder(ms) | 加速比 |
|--------|---------------|---------------|--------|
| 1 | | | |
| 2 | | | |
| 4 | | | |
| 8 | | | |
| 16 | | | |
| 32 | | | |

#### 步骤4：绘制性能曲线（可选）

根据上面的数据，画出性能曲线的趋势：

```
性能(ms)
    ^
    |
    |    AtomicLong
    |   /
    |  /
    | /      LongAdder
    |/     ___________
    +--+--+--+--+--+--→ 线程数
    1  2  4  8  16 32
```

#### 步骤5：分析结果

- 低并发时（1-2线程），谁更快？为什么？
  - 
- 高并发时（16-32线程），加速比是多少？
  - 
- 性能差异的根本原因是什么？
  - 

### 扩展实验（选做）

#### 扩展1：增加每线程操作次数

```java
// 修改操作次数
int operationsPerThread = 10_000_000;  // 增加到1000万
```

#### 扩展2：测试 CPU 核心数对 LongAdder 的影响

查看你的 CPU 核心数：
```bash
# macOS
sysctl -n hw.ncpu

# Linux
nproc
```

你的 CPU 核心数：________

Cell 数组最大值 = CPU 核心数，记录：
- 线程数 < CPU 核心数时的加速比：________
- 线程数 = CPU 核心数时的加速比：________
- 线程数 > CPU 核心数时的加速比：________（是否继续提升？）

### 思考题

1. **LongAdder 的 sum() 为什么不是精确值？在什么场景下这不是问题？**
   - 
2. **Cell 数组最大为 CPU 核心数，为什么不能更大？**
   - 
3. **@Contended 注解解决的"伪共享"问题是什么？**
   - 
4. **在什么场景下应该选择 AtomicLong 而不是 LongAdder？**
   - 

### 验收标准

- [ ] 能量化 LongAdder 在高并发下的性能优势
- [ ] 能解释 LongAdder 分段思想的工作原理
- [ ] 能说出 Cell 数组的扩容策略
- [ ] 能区分 LongAdder 和 AtomicLong 的适用场景

---

## 5. 综合验收

完成所有实验后，回答以下综合问题：

### 5.1 知识串联

1. **CAS → Atomic → AQS → Lock 的关系是什么？**
   - 

2. **为什么 AQS 选择 CAS + volatile state 而不是直接用 synchronized？**
   - 

3. **你觉得 Java 并发工具的设计中，最巧妙的设计是什么？为什么？**
   - 

### 5.2 实验总结

| 实验 | 完成情况 | 关键收获 |
|------|---------|---------|
| A: CAS 与 ABA | [ ] 完成 | |
| B: 自定义 AQS 锁 | [ ] 完成 | |
| C: 公平/非公平锁 | [ ] 完成 | |
| D: LongAdder 性能 | [ ] 完成 | |

### 5.3 面试模拟

请用 3 分钟时间，模拟回答以下面试题：

> **面试官**：请你讲一下 AQS 的核心原理，以及 ReentrantLock 是如何基于 AQS 实现的？

你的回答：

```
（在此写下你的回答）
```

---

> **提示**：完成所有实验后，请在 `02-学习笔记.md` 中记录你的实验结果和思考。
