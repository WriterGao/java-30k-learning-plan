# Day05 学习笔记

> **学习目标**：今天的笔记目标是"**能复述、能画图、能用代码验证**"，不要抄书。  
> **参考课件**：`00-教学课件_CAS与AQS原理详解.md`

---

## 1. CAS 原理（用你自己的话）

### 1.1 CAS 是什么？

请用一句话概括 CAS：

- 

### 1.2 CAS 的底层实现

请描述 CAS 从 Java 代码到 CPU 指令的调用链：

```
Java 代码 → ? → ? → ?
```

- Unsafe 类的作用：
- CPU cmpxchg 指令的作用：
- lock 前缀的作用：

### 1.3 CAS 自旋的过程

请画出 CAS 自旋的流程图（可用 ASCII 或文字描述）：

```
（在此画图）
```

---

## 2. CAS 三大问题

### 2.1 ABA 问题

- **什么是 ABA 问题**：
- **为什么危险**（举一个具体场景）：
- **解决方案1 - AtomicStampedReference**：
- **解决方案2 - AtomicMarkableReference**：
- **两者的区别**：

### 2.2 循环时间长开销大

- **为什么会有这个问题**：
- **解决方案**：

### 2.3 只能保证一个变量的原子性

- **为什么有这个限制**：
- **解决方案**：

---

## 3. Atomic 原子类家族

### 3.1 分类整理

请填写各类原子类：

| 分类 | 类名 | 用途 |
|------|------|------|
| 基本类型 | | |
| 引用类型 | | |
| 数组类型 | | |
| 字段更新器 | | |
| 累加器 | | |

### 3.2 LongAdder 原理

- **为什么比 AtomicLong 快**：
- **分段思想是什么**：
- **Cell 数组的作用**：
- **@Contended 注解的作用**：
- **sum() 为什么不是原子操作**：

### 3.3 实验观察

运行 `code/LongAdderVsAtomicDemo.java` 后记录结果：

| 线程数 | AtomicLong(ms) | LongAdder(ms) | 加速比 |
|--------|---------------|---------------|--------|
| 1 | | | |
| 4 | | | |
| 8 | | | |
| 16 | | | |
| 32 | | | |

你的观察和结论：
- 

---

## 4. AQS 原理

### 4.1 AQS 核心设计

请画出 AQS 的核心结构图（state + CLH 队列）：

```
（在此画图）
```

- **state 变量的作用**：
- **CLH 队列是什么**：
- **Node 节点包含哪些信息**：
- **waitStatus 有哪些取值**：

### 4.2 独占模式 vs 共享模式

| 特性 | 独占模式 | 共享模式 |
|------|---------|---------|
| 同时获取 | | |
| 需实现方法 | | |
| 典型实现 | | |
| 唤醒方式 | | |

### 4.3 acquire 获取锁流程

请用自己的话描述 acquire 的完整流程（参考课件5.4）：

1. 
2. 
3. 
4. 

### 4.4 release 释放锁流程

请用自己的话描述 release 的完整流程（参考课件5.5）：

1. 
2. 
3. 

### 4.5 Condition 条件队列

- **await 做了什么**：
- **signal 做了什么**：
- **条件队列和同步队列的关系**：

---

## 5. ReentrantLock 源码分析

### 5.1 公平锁 vs 非公平锁

请写出两者在代码层面的**核心差异**（至少3点）：

1. 
2. 
3. 

### 5.2 lock/unlock 调用链

请写出 NonfairSync 的 lock 调用链：

```
lock() → ? → ? → ?
```

请写出 unlock 调用链：

```
unlock() → ? → ? → ?
```

### 5.3 可重入的实现

- **获取锁时如何实现可重入**：
- **释放锁时如何处理**：
- **holdCount 的含义**：

### 5.4 实验观察

运行 `code/ReentrantLockDemo.java` 后记录：

- 公平锁获取顺序：
- 非公平锁获取顺序：
- 性能比（公平/非公平）：

### 5.5 与 synchronized 对比

| 对比维度 | synchronized | ReentrantLock |
|---------|-------------|---------------|
| 实现层面 | | |
| 锁释放 | | |
| 可中断 | | |
| 超时获取 | | |
| 公平性 | | |
| 条件变量 | | |

---

## 6. ReentrantReadWriteLock

### 6.1 state 的设计

请解释 state 的高16位/低16位设计：

- **高16位**：
- **低16位**：
- **位操作**：
  - 获取读锁数量：
  - 获取写锁数量：

### 6.2 锁降级

- **什么是锁降级**：
- **标准写法**：
- **为什么不支持锁升级**：

---

## 7. CountDownLatch / Semaphore / CyclicBarrier

### 7.1 三者对比

| 特性 | CountDownLatch | CyclicBarrier | Semaphore |
|------|---------------|---------------|-----------|
| 用途 | | | |
| 可重用 | | | |
| 基于 | | | |
| 核心方法 | | | |
| 典型场景 | | | |

### 7.2 各自的 AQS 实现原理

- **CountDownLatch**：state 表示什么？如何工作？
  - 
- **Semaphore**：state 表示什么？如何工作？
  - 
- **CyclicBarrier**：为什么不直接基于 AQS？
  - 

---

## 8. StampedLock

### 8.1 三种模式

- **写锁**：
- **悲观读锁**：
- **乐观读**：

### 8.2 乐观读的流程

1. 
2. 
3. 
4. 

### 8.3 与 ReentrantReadWriteLock 的区别

| 特性 | ReentrantReadWriteLock | StampedLock |
|------|----------------------|-------------|
| 乐观读 | | |
| 可重入 | | |
| Condition | | |
| 适用场景 | | |

---

## 9. 5 分钟复述稿（面试式）

用 5 分钟讲清楚"CAS 与 AQS 原理"，要求：
- 先总览，再逐一解释，再给关键实现细节

**我的复述稿**：

```
【CAS 部分】
CAS 是 Compare And Swap，一种无锁原子操作...
底层通过 Unsafe 类调用 CPU 的 cmpxchg 指令...
三大问题：ABA、自旋开销、单变量限制...

【AQS 部分】
AQS 是 Java 并发包的核心框架...
核心设计：state 变量 + CLH 等待队列...
独占模式和共享模式...

【ReentrantLock】
公平锁和非公平锁的区别...
lock/unlock 的完整调用链...

【实际应用】
举一个你在项目中使用的例子...
```

---

## 10. 学习总结与疑问

### 10.1 今天学到的核心知识点

1. 
2. 
3. 
4. 
5. 

### 10.2 还有疑问的地方

1. 
2. 

### 10.3 下一步学习计划

- [ ] 复习课件第11章的检查清单
- [ ] 阅读 AQS 源码（AbstractQueuedSynchronizer.java）
- [ ] 准备下一天的学习

---

> **提示**：完成笔记后，对照课件第11章的检查清单进行自我验收。
