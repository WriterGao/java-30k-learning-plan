# Day07 实验与练习：并发工具类

> 对应课件：`00-教学课件_并发工具类详解.md`  
> 实验代码：`code/` 目录

---

## 实验 A：CountDownLatch + CyclicBarrier 对比实验

### 实验目标

1. 理解 CountDownLatch 的"一个等多个"模式
2. 理解 CyclicBarrier 的"互相等待"模式
3. 对比两者的差异（一次性 vs 可循环、等待模式、回调支持）

### 实验步骤

#### A-1：运行 CountDownLatch 演示

```bash
cd Day07/code
javac CountDownLatchDemo.java
java CountDownLatchDemo
```

**观察要点**：
1. 演示1 中主线程通过 `await()` 等待，子线程通过 `countDown()` 通知
2. 演示2 中多个服务并行启动，总耗时约等于最慢的服务
3. 演示3 中 `CountDownLatch(1)` 作为开关（发令枪）
4. 演示4 中带超时的等待，超时后未完成的任务不影响主线程

**记录**：

```
演示1 运行结果：


演示2 并行启动总耗时 vs 估计的串行耗时：


演示3 发令枪效果（是否所有运动员几乎同时起跑？）：


演示4 超时后的计数值：


```

#### A-2：运行 CyclicBarrier 演示

```bash
javac CyclicBarrierDemo.java
java CyclicBarrierDemo
```

**观察要点**：
1. 演示1 中所有线程互相等待，全部到达后才继续
2. 演示2 中 barrierAction 是由哪个线程执行的？（最后到达的线程）
3. 演示3 中 CyclicBarrier 确实可以循环使用（多轮）
4. 演示4 中超时后屏障被打破（BrokenBarrierException）

**记录**：

```
演示1 所有玩家是否几乎同时开始游戏：


演示2 barrierAction 的执行线程名：


演示3 循环复用了几轮：


演示4 BrokenBarrierException 的表现：


```

#### A-3：对比分析

完成以下对比表（根据观察结果填写）：

| 对比维度 | CountDownLatch | CyclicBarrier |
|----------|----------------|---------------|
| 等待方式 | | |
| 计数方式 | | |
| 是否可重用 | | |
| 异常影响 | | |
| 回调支持 | | |
| 适用场景 | | |

### 验收标准

- [ ] 能运行两个 Demo 并观察到预期行为
- [ ] 能清晰描述 CountDownLatch 和 CyclicBarrier 的区别
- [ ] 能说出 barrierAction 由哪个线程执行
- [ ] 理解 BrokenBarrierException 的触发条件

---

## 实验 B：Semaphore 实现连接池

### 实验目标

1. 理解 Semaphore 的许可证机制
2. 用 Semaphore 实现一个简单的连接池限流
3. 观察公平/非公平模式的差异
4. 掌握 tryAcquire 的非阻塞获取

### 实验步骤

#### B-1：运行 Semaphore 演示

```bash
javac SemaphoreDemo.java
java SemaphoreDemo
```

**观察要点**：
1. 演示1 中同一时刻最多只有 3 个线程获取许可
2. 演示2 中停车场模拟——排队等待的效果
3. 演示3 中公平模式是否严格按顺序获取
4. 演示4 中 tryAcquire 在许可不足时立即返回 false

**记录**：

```
演示1 同时获取许可的最大线程数：


演示2 等待时间最长的车辆：


演示3 公平模式 vs 非公平模式的获取顺序差异：


演示4 tryAcquire(timeout) 的超时行为：


```

#### B-2：动手练习——实现简易连接池

基于以下框架，用 Semaphore 实现一个简易的数据库连接池：

```java
import java.util.concurrent.*;

/**
 * 练习：用 Semaphore 实现简易连接池
 */
public class SimpleConnectionPool {
    private final Semaphore semaphore;
    private final LinkedBlockingQueue<String> pool; // 用 String 模拟 Connection

    public SimpleConnectionPool(int poolSize) {
        // TODO: 初始化 Semaphore 和连接池
        this.semaphore = new Semaphore(poolSize);
        this.pool = new LinkedBlockingQueue<>();
        for (int i = 0; i < poolSize; i++) {
            pool.offer("Connection-" + (i + 1));
        }
    }

    /**
     * 获取连接（阻塞等待）
     */
    public String getConnection() throws InterruptedException {
        // TODO: 先 acquire 许可，再从池中取连接
        semaphore.acquire();
        return pool.poll();
    }

    /**
     * 获取连接（带超时）
     */
    public String getConnection(long timeout, TimeUnit unit)
            throws InterruptedException {
        // TODO: 用 tryAcquire 实现超时获取
        if (!semaphore.tryAcquire(timeout, unit)) {
            throw new RuntimeException("获取连接超时");
        }
        return pool.poll();
    }

    /**
     * 归还连接
     */
    public void releaseConnection(String connection) {
        // TODO: 归还到池中，再 release 许可
        pool.offer(connection);
        semaphore.release();
    }

    /**
     * 获取可用连接数
     */
    public int availableConnections() {
        return semaphore.availablePermits();
    }

    // 测试
    public static void main(String[] args) throws Exception {
        SimpleConnectionPool pool = new SimpleConnectionPool(3);
        ExecutorService executor = Executors.newFixedThreadPool(10);

        for (int i = 1; i <= 10; i++) {
            final int taskId = i;
            executor.submit(() -> {
                try {
                    System.out.println("任务" + taskId + " 等待连接... (可用: "
                        + pool.availableConnections() + ")");

                    String conn = pool.getConnection();
                    System.out.println("任务" + taskId + " 获取到 " + conn);

                    // 模拟数据库操作
                    Thread.sleep((long) (Math.random() * 2000 + 500));

                    pool.releaseConnection(conn);
                    System.out.println("任务" + taskId + " 归还 " + conn);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });
        }

        executor.shutdown();
        executor.awaitTermination(30, TimeUnit.SECONDS);
        System.out.println("所有任务完成，可用连接: " + pool.availableConnections());
    }
}
```

**运行并观察**：
- 同一时刻最多 3 个任务持有连接
- 其他任务在排队等待
- 所有任务完成后连接数恢复

### 验收标准

- [ ] 能运行 SemaphoreDemo 并观察限流效果
- [ ] 能说出公平/非公平模式的区别
- [ ] 能实现基于 Semaphore 的简易连接池
- [ ] 理解 acquire/release 配对使用的重要性

---

## 实验 C：CompletableFuture 并行调用

### 实验目标

1. 掌握 CompletableFuture 的创建、链式调用、异常处理
2. 掌握 allOf/anyOf 的使用
3. 实现并行调用多个服务并聚合结果
4. 理解自定义线程池的重要性

### 实验步骤

#### C-1：运行 CompletableFuture 演示

```bash
javac CompletableFutureDemo.java
java CompletableFutureDemo
```

**观察要点**：
1. 演示1：supplyAsync/runAsync 的执行线程名
2. 演示2：链式调用的执行顺序和结果传递
3. 演示3：exceptionally/handle/whenComplete 的异常处理效果
4. 演示4：allOf 的总耗时是否约等于最慢的任务
5. 演示5：并行调用多个微服务的耗时优势

**记录**：

```
演示1 执行线程名是什么？（是 ForkJoinPool 还是自定义线程池？）


演示2 thenCompose 和 thenCombine 的区别：


演示3 各种异常处理的效果：


演示4 allOf 总耗时 vs 单个最慢任务耗时：


演示5 并行调用总耗时 vs 估计串行总耗时：


```

#### C-2：动手练习——实现商品详情页聚合

参考以下框架，实现一个商品详情页的并行数据聚合服务：

```java
import java.util.concurrent.*;

/**
 * 练习：用 CompletableFuture 实现商品详情页并行聚合
 *
 * 需求：
 * 1. 并行调用 4 个服务：用户服务、商品服务、库存服务、优惠券服务
 * 2. 每个服务都要有异常降级处理
 * 3. 设置总超时时间（3秒）
 * 4. 超时后用已有数据 + 默认值组装结果
 */
public class ProductDetailAggregator {
    private static final ExecutorService executor =
        Executors.newFixedThreadPool(8);

    public static void main(String[] args) {
        long start = System.currentTimeMillis();

        // TODO: 创建 4 个 CompletableFuture，分别调用模拟服务
        // TODO: 每个都加 exceptionally 降级处理
        // TODO: 用 allOf + get(3, SECONDS) 等待
        // TODO: 用 getNow(default) 获取结果
        // TODO: 输出聚合结果和总耗时

        CompletableFuture<String> userFuture = CompletableFuture
            .supplyAsync(() -> callUserService(), executor)
            .exceptionally(ex -> "默认用户");

        CompletableFuture<String> productFuture = CompletableFuture
            .supplyAsync(() -> callProductService(), executor)
            .exceptionally(ex -> "默认商品");

        CompletableFuture<String> stockFuture = CompletableFuture
            .supplyAsync(() -> callStockService(), executor)
            .exceptionally(ex -> "库存未知");

        CompletableFuture<String> couponFuture = CompletableFuture
            .supplyAsync(() -> callCouponService(), executor)
            .exceptionally(ex -> "无优惠");

        try {
            CompletableFuture.allOf(userFuture, productFuture, stockFuture, couponFuture)
                .get(3, TimeUnit.SECONDS);
        } catch (TimeoutException e) {
            System.out.println("⚠️ 部分服务超时");
        } catch (Exception e) {
            System.out.println("⚠️ 聚合异常: " + e.getMessage());
        }

        // 组装结果
        String user = userFuture.getNow("默认用户");
        String product = productFuture.getNow("默认商品");
        String stock = stockFuture.getNow("库存未知");
        String coupon = couponFuture.getNow("无优惠");

        long elapsed = System.currentTimeMillis() - start;
        System.out.println("===== 商品详情页 =====");
        System.out.println("用户: " + user);
        System.out.println("商品: " + product);
        System.out.println("库存: " + stock);
        System.out.println("优惠: " + coupon);
        System.out.println("总耗时: " + elapsed + "ms");

        executor.shutdown();
    }

    // ===== 模拟服务调用 =====

    static String callUserService() {
        sleep(800);
        return "张三 (VIP)";
    }

    static String callProductService() {
        sleep(600);
        return "iPhone 15 Pro ¥7999";
    }

    static String callStockService() {
        sleep(400);
        // 模拟偶尔异常
        if (Math.random() < 0.3) {
            throw new RuntimeException("库存服务异常");
        }
        return "库存: 128件";
    }

    static String callCouponService() {
        sleep(500);
        return "满减券: -500元";
    }

    static void sleep(long ms) {
        try { Thread.sleep(ms); } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
```

**观察**：
- 总耗时是否约 800ms（最慢服务的耗时）
- 库存服务异常时是否正确降级
- 多次运行对比结果

#### C-3：进阶练习——链式调用

尝试用 CompletableFuture 的链式调用实现以下业务流程：

```
查询用户 → 根据用户等级查询折扣 → 计算最终价格
                                  ↑
          查询商品原价 ─────────────┘
```

```java
// 提示代码
CompletableFuture<String> userFuture = CompletableFuture
    .supplyAsync(() -> "VIP用户");

CompletableFuture<Double> discountFuture = userFuture
    .thenCompose(user -> CompletableFuture.supplyAsync(() -> {
        // 根据用户等级查询折扣
        return user.contains("VIP") ? 0.8 : 1.0;
    }));

CompletableFuture<Double> priceFuture = CompletableFuture
    .supplyAsync(() -> 100.0); // 商品原价

CompletableFuture<Double> finalPriceFuture = discountFuture
    .thenCombine(priceFuture, (discount, price) -> price * discount);

System.out.println("最终价格: " + finalPriceFuture.join());
```

### 验收标准

- [ ] 能运行 CompletableFutureDemo 并理解每个演示
- [ ] 能实现并行调用 + 异常降级 + 超时保护
- [ ] 理解 thenApply/thenCompose/thenCombine 的区别
- [ ] 理解为什么要用自定义线程池
- [ ] 能用 CompletableFuture 实现复杂的异步任务编排

---

## 实验 D：Fork/Join 大数组求和

### 实验目标

1. 理解 Fork/Join 的分治思想和工作窃取算法
2. 掌握 RecursiveTask 的使用
3. 对比串行计算和 Fork/Join 并行计算的性能
4. 理解阈值（THRESHOLD）对性能的影响

### 实验步骤

#### D-1：运行 Fork/Join 演示

```bash
javac ForkJoinDemo.java
java ForkJoinDemo
```

**观察要点**：
1. 串行求和 vs 并行求和的结果是否一致
2. 并行求和的加速比（串行耗时/并行耗时）
3. 工作窃取次数（stealCount）
4. 不同数据量下的性能对比

**记录**：

```
数组大小: 10,000,000
串行耗时: ___ms
并行耗时: ___ms
加速比: ___x
窃取次数: ___

数组大小: 100,000,000
串行耗时: ___ms
并行耗时: ___ms
加速比: ___x
窃取次数: ___
```

#### D-2：阈值实验

修改 `ForkJoinDemo.java` 中的 THRESHOLD 值，观察对性能的影响：

| THRESHOLD | 数组大小 | 并行耗时 | 加速比 | 窃取次数 |
|-----------|----------|----------|--------|----------|
| 1,000 | 10,000,000 | | | |
| 10,000 | 10,000,000 | | | |
| 100,000 | 10,000,000 | | | |
| 1,000,000 | 10,000,000 | | | |

```
最优阈值大约是多少？


阈值太小的问题：


阈值太大的问题：


```

#### D-3：运行 Fork/Join 排序演示（附加）

```bash
javac ForkJoinSortDemo.java
java ForkJoinSortDemo
```

**观察要点**：
1. Fork/Join 归并排序 vs Arrays.sort 的性能对比
2. 不同数组大小下的加速比变化
3. 小数组时 Fork/Join 可能反而更慢（开销大于收益）

**记录**：

```
不同数组大小下的性能对比表：

| 数组大小 | Arrays.sort | Fork/Join排序 | 加速比 |
|----------|-------------|---------------|--------|
| 100,000  |             |               |        |
| 500,000  |             |               |        |
| 1,000,000|             |               |        |
| 5,000,000|             |               |        |
```

### 验收标准

- [ ] 能运行 Fork/Join 演示并观察到性能提升
- [ ] 能解释工作窃取算法的原理
- [ ] 能说出阈值对性能的影响
- [ ] 理解 fork/compute/join 的正确使用模式
- [ ] 了解 Fork/Join 在小数据量下可能无优势

---

## 综合练习

### 练习 1：并发工具选型

针对以下场景，选择最合适的并发工具并说明理由：

| 场景 | 你的选择 | 理由 |
|------|----------|------|
| 微服务启动时等待所有组件初始化 | | |
| 多线程分批处理数据，每批完成后汇总 | | |
| 限制数据库连接池的并发访问数 | | |
| 并行调用多个 HTTP 接口并聚合结果 | | |
| 大文件分块并行处理 | | |
| 订单超时 30 分钟自动取消 | | |
| 读多写少的事件监听器列表 | | |
| 两个线程之间交换处理结果 | | |

### 练习 2：面试模拟

不看资料，尝试回答以下问题（可以之后对照课件检查）：

1. CountDownLatch 和 CyclicBarrier 的 3 个核心区别？
2. CompletableFuture 的 thenApply 和 thenCompose 有什么区别？
3. Fork/Join 的工作窃取算法为什么从尾部窃取？
4. ArrayBlockingQueue 和 LinkedBlockingQueue 的锁机制区别？
5. CopyOnWriteArrayList 为什么适合读多写少的场景？

---

## 实验注意事项

1. **每个实验都要实际运行代码**——不要只看不跑
2. **多次运行**——并发程序每次执行可能结果不同，多跑几次观察
3. **修改参数**——改变线程数、超时时间、数据量等参数，观察行为变化
4. **记录数据**——性能数据、异常行为都记录在笔记中
5. **思考为什么**——不仅观察现象，还要思考底层原因
