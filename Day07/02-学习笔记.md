# Day07 学习笔记：并发工具类

> 学习日期：____年__月__日  
> 学习时长：____ 小时  
> 对应课件：`00-教学课件_并发工具类详解.md`

---

## 一、CountDownLatch

### 1.1 核心原理（用自己的话描述）

_提示：基于 AQS 共享模式，state 存储计数值，await() 时 state≠0 则阻塞，countDown() 将 state CAS 减 1，减到 0 唤醒等待线程_

```
我的理解：



```

### 1.2 关键方法

| 方法 | 作用 | 源码关键点 |
|------|------|-----------|
| `countDown()` | | |
| `await()` | | |
| `await(timeout)` | | |

### 1.3 使用场景

```
场景1：


场景2：


```

### 1.4 代码实验记录

运行 `CountDownLatchDemo.java` 后的观察：

```
运行结果记录：



关键发现：


```

---

## 二、CyclicBarrier

### 2.1 核心原理

_提示：基于 ReentrantLock + Condition，非 AQS 共享模式_

```
我的理解：



```

### 2.2 与 CountDownLatch 的对比

| 对比维度 | CountDownLatch | CyclicBarrier |
|----------|----------------|---------------|
| 实现原理 | | |
| 可重用性 | | |
| 等待主体 | | |
| 计数方式 | | |
| 回调支持 | | |
| 异常传播 | | |

### 2.3 barrierAction 的执行线程

```
关键结论：barrierAction 由哪个线程执行？



```

### 2.4 代码实验记录

运行 `CyclicBarrierDemo.java` 后的观察：

```
运行结果记录：



对比 CountDownLatch 的不同点：


```

---

## 三、Semaphore

### 3.1 核心原理

_提示：基于 AQS 共享模式，state 存储可用许可数_

```
我的理解：



```

### 3.2 公平 vs 非公平

```
区别：



源码差异点：


```

### 3.3 使用注意事项

```
注意点1（release 可以增加许可超过初始值）：


注意点2（acquire 和 release 不必是同一线程）：


注意点3（必须在 finally 中 release）：


```

### 3.4 代码实验记录

运行 `SemaphoreDemo.java` 后的观察：

```
运行结果记录：



限流效果观察：


```

---

## 四、Exchanger

### 4.1 核心原理

```
我的理解：



```

### 4.2 使用场景

```
场景：生产者-消费者交换缓冲区




为什么 Exchanger 在实际项目中使用较少？


```

---

## 五、Phaser

### 5.1 核心原理

_提示：结合了 CountDownLatch + CyclicBarrier 的功能，支持动态注册/注销参与者_

```
我的理解：



```

### 5.2 与 CountDownLatch / CyclicBarrier 的对比

| 特性 | CountDownLatch | CyclicBarrier | Phaser |
|------|----------------|---------------|--------|
| 可重用 | | | |
| 动态参与者 | | | |
| 多阶段 | | | |
| 阶段回调 | | | |
| 参与者退出 | | | |

### 5.3 关键方法理解

```
arrive() vs arriveAndAwaitAdvance() 的区别：


arriveAndDeregister() 的作用：


onAdvance() 的作用：


```

---

## 六、CompletableFuture（重点）

### 6.1 Future 的不足

```
列举 Future 的5大不足：
1. 
2. 
3. 
4. 
5. 
```

### 6.2 创建方式

```
supplyAsync 和 runAsync 的区别：


为什么推荐使用自定义线程池：


```

### 6.3 链式调用

| 方法 | 功能 | 类比 |
|------|------|------|
| `thenApply` | | Stream.map |
| `thenAccept` | | |
| `thenRun` | | |
| `thenCompose` | | Stream.flatMap |
| `thenCombine` | | |

```
thenApply vs thenCompose 的区别（重要！）：



```

### 6.4 异常处理

| 方法 | 触发条件 | 能否改变返回值 |
|------|----------|----------------|
| `exceptionally` | | |
| `handle` | | |
| `whenComplete` | | |

### 6.5 组合操作

```
allOf 的返回值类型和使用方式：


anyOf 的返回值类型和使用方式：


```

### 6.6 最佳实践总结

```
1. 
2. 
3. 
4. 
5. 
```

### 6.7 代码实验记录

运行 `CompletableFutureDemo.java` 后的观察：

```
运行结果记录：



并行调用 vs 串行调用的耗时对比：


```

---

## 七、Fork/Join 框架

### 7.1 工作窃取算法理解

```
什么是工作窃取？


为什么从双端队列的尾部窃取？


```

### 7.2 RecursiveTask vs RecursiveAction

| 对比 | RecursiveTask | RecursiveAction |
|------|---------------|-----------------|
| 返回值 | | |
| 典型场景 | | |

### 7.3 fork/join/compute 的正确使用

```
为什么推荐 "先 fork 再 compute" 而不是 "两个都 fork"？



```

### 7.4 代码实验记录

运行 `ForkJoinDemo.java` 后的观察：

```
运行结果记录：



串行 vs 并行的性能对比：


工作窃取次数：


```

---

## 八、BlockingQueue 家族

### 8.1 六种实现对比

| 实现 | 数据结构 | 有界/无界 | 锁机制 | 适用场景 |
|------|----------|-----------|--------|----------|
| ArrayBlockingQueue | | | | |
| LinkedBlockingQueue | | | | |
| PriorityBlockingQueue | | | | |
| DelayQueue | | | | |
| SynchronousQueue | | | | |
| LinkedTransferQueue | | | | |

### 8.2 ArrayBlockingQueue vs LinkedBlockingQueue

```
关键区别（锁机制）：



为什么 LinkedBlockingQueue 吞吐量通常更高？


```

### 8.3 put/take vs offer/poll

```
什么时候用阻塞版本，什么时候用非阻塞版本？



```

---

## 九、CopyOnWriteArrayList

### 9.1 写时复制原理

```
读操作为什么不需要加锁？


写操作的步骤（3步）：
1. 
2. 
3. 
```

### 9.2 优缺点

```
优点：


缺点：


适用场景：


```

---

## 十、并发工具选型

### 10.1 选型总结

```
一个等多个 → 
互相等待 → 
动态参与者多阶段 → 
限流 → 
异步任务编排 → 
分治计算 → 
生产者消费者 → 
读多写少列表 → 
```

---

## 十一、本周总结

### 11.1 第一周学习回顾

```
JVM 部分关键知识点：


并发部分关键知识点：


我觉得最重要的3个知识点：
1. 
2. 
3. 
```

### 11.2 学习收获与疑问

```
本日最大收获：


仍然困惑的问题：


需要重点复习的内容：


```

---

## 十二、面试准备

### 12.1 需要背诵的面试答案

```
CountDownLatch vs CyclicBarrier（5个区别）：


CompletableFuture vs Future（5个优势）：


Fork/Join 工作窃取算法：


```

### 12.2 自测通过情况

- [ ] 能画出 CountDownLatch 的时序图
- [ ] 能说出 CyclicBarrier 的实现原理（ReentrantLock + Condition）
- [ ] 能写出 Semaphore 限流的代码
- [ ] 能写出 CompletableFuture 并行调用 + 异常处理的代码
- [ ] 能说出 6 种 BlockingQueue 的特点
- [ ] 能说出 CopyOnWriteArrayList 的优缺点
- [ ] 能回答 12 道面试题的核心要点
