# Day04 实验与练习

> **参考课件**：`00-教学课件_多线程基础详解.md`  
> **实验代码**：`code/` 目录

---

## 0. 环境准备

### 必需工具

- **JDK**：建议使用你正在学习/工作使用的版本（例如 17/21），保持一致
- **监控工具**：
  - `jstack`：线程栈分析（推荐，必须掌握）
  - `jconsole` / `VisualVM`：图形化线程监控（可选）
  - `jps`：查看 Java 进程 ID

### 工具检查

```bash
# 检查 JDK 版本
java -version

# 检查 jstack 是否可用
jstack -h

# 编译所有实验代码
cd Day04/code
javac *.java
```

> **备注**：本次实验重点使用 `jstack` 观察线程状态，建议提前熟悉用法。

---

## 实验 A：观察线程状态转换

### 实验目标

观察 Java 线程的 6 种状态（NEW / RUNNABLE / BLOCKED / WAITING / TIMED_WAITING / TERMINATED），理解状态之间的转换条件。

### 实验代码

**文件**：`code/ThreadStateDemo.java`

**参考课件**：第 3 章

### 实验步骤

1. **编译代码**：
   ```bash
   javac ThreadStateDemo.java
   ```

2. **运行代码**：
   ```bash
   java ThreadStateDemo
   ```

3. **观察输出**，记录每种状态：
   - 实验1：NEW → TERMINATED
   - 实验2：RUNNABLE（忙循环）
   - 实验3：TIMED_WAITING（sleep）
   - 实验4：WAITING（wait）
   - 实验5：BLOCKED（锁竞争）
   - 实验6：完整生命周期

4. **进阶**：在实验运行期间，开另一个终端用 `jstack` 观察：
   ```bash
   # 查找进程 ID
   jps
   # 导出线程栈
   jstack <pid>
   ```

### 验收标准

- [ ] 能看到 6 种状态的输出
- [ ] 理解每种状态的进入条件
- [ ] 理解 BLOCKED 和 WAITING 的区别
- [ ] 能用 jstack 查看线程状态

### 实验记录

**运行结果**：
```
（粘贴关键输出）
```

**我的理解**：
```
1. NEW 和 TERMINATED 的区别：
2. BLOCKED 和 WAITING 的区别：
3. TIMED_WAITING 和 WAITING 的区别：
```

---

## 实验 B：synchronized 锁升级验证

### 实验目标

1. 验证不加锁时的线程安全问题
2. 验证 synchronized 的正确使用
3. 理解对象锁 vs 类锁的区别
4. 验证 synchronized 的可重入性
5. 观察死锁的产生与排查

### 实验代码

**文件**：`code/SynchronizedDemo.java`

**参考课件**：第 5 章

### 实验步骤

#### 步骤1：观察线程安全问题

```bash
javac SynchronizedDemo.java
java SynchronizedDemo
```

观察实验1的输出：
- 10个线程各执行10000次 `count++`
- 期望值 = 100000
- 实际值是多少？差了多少？

#### 步骤2：观察 synchronized 修复

观察实验2的输出：
- 使用 `synchronized` 后，结果是否正确？

#### 步骤3：理解对象锁 vs 类锁

观察实验3的输出，回答以下问题：
- 同一对象的两个 synchronized 方法是否互斥？
- 不同对象的 synchronized 方法是否互斥？
- static synchronized 方法在不同对象间是否互斥？

#### 步骤4：观察死锁

观察实验5的输出：
- 两个线程的状态分别是什么？
- 使用 jstack 查看死锁信息：

```bash
# 在死锁检测期间（3秒内）
jps
jstack <pid>
# 搜索 "Found one Java-level deadlock"
```

### 验收标准

- [ ] 亲眼看到不加锁时的数据丢失
- [ ] 理解 synchronized 如何保证原子性
- [ ] 理解对象锁和类锁的区别
- [ ] 理解 synchronized 的可重入性
- [ ] 亲眼看到死锁，能用 jstack 排查

### 实验记录

**实验1（线程不安全）**：
```
期望值: 100000
实际值: ___
差值: ___
```

**实验2（synchronized 修复）**：
```
期望值: 100000
实际值: ___
```

**实验3（锁类型对比）**：
```
测试A（同一对象两个sync方法）：是否互斥？___
测试B（不同对象sync方法）：是否互斥？___
测试C（static synchronized）：是否互斥？___
```

**实验5（死锁）**：
```
线程1状态: ___
线程2状态: ___
jstack 是否检测到死锁: ___
```

---

## 实验 C：volatile 可见性验证

### 实验目标

1. 复现不使用 volatile 时的可见性问题
2. 验证 volatile 解决可见性问题
3. 验证 volatile 不保证原子性
4. 理解 volatile 的正确使用场景

### 实验代码

**文件**：`code/VolatileDemo.java`

**参考课件**：第 6 章

### 实验步骤

#### 步骤1：可见性问题复现

```bash
javac VolatileDemo.java
java VolatileDemo
```

> **注意**：可见性问题不一定每次复现。如果未复现，尝试：
> ```bash
> java -server VolatileDemo
> ```
> 或多运行几次。

观察实验1：
- 主线程修改 `running = false` 后，工作线程是否退出？
- 如果 2 秒内未退出，说明什么？

#### 步骤2：volatile 修复

观察实验2：
- 使用 `volatile` 后，工作线程是否能看到更新？

#### 步骤3：volatile 不保证原子性

观察实验3：
- `volatile int count` + 10个线程各执行10000次 `count++`
- 期望值 = 100000
- 实际值是多少？
- `AtomicInteger` 的结果是多少？

#### 步骤4：正确使用场景

观察实验4：
- 优雅停机（状态标志）是否生效？
- DCL 单例是否正确？

### 验收标准

- [ ] 理解可见性问题的原因（工作内存缓存）
- [ ] 理解 volatile 如何解决可见性
- [ ] 亲眼看到 volatile 不保证原子性
- [ ] 知道什么场景该用 volatile，什么场景不该用

### 实验记录

**实验1（可见性问题）**：
```
是否复现: ___
现象描述: ___
```

**实验2（volatile 修复）**：
```
工作线程是否成功退出: ___
```

**实验3（非原子性）**：
```
volatile count++ 结果:
  期望值: 100000
  实际值: ___
AtomicInteger 结果:
  期望值: 100000
  实际值: ___
```

**实验4（正确使用场景）**：
```
优雅停机: ___
DCL 单例: ___
```

---

## 实验 D：生产者消费者模式实现

### 实验目标

1. 理解 wait/notify 的工作机制
2. 掌握生产者消费者模式的两种实现
3. 理解 BlockingQueue 的优势

### 实验代码

**文件**：`code/ProducerConsumerDemo.java`

**参考课件**：第 4 章（wait/notify）

### 实验步骤

#### 步骤1：wait/notify 实现

```bash
javac ProducerConsumerDemo.java
java ProducerConsumerDemo
```

观察实现1的输出：
- 生产者和消费者是否交替工作？
- 队列满时，生产者是否阻塞等待？
- 队列空时，消费者是否阻塞等待？

#### 步骤2：BlockingQueue 实现

观察实现2的输出：
- 使用 BlockingQueue 是否更简洁？
- 毒丸模式（Poison Pill）是否正确停止消费者？

#### 步骤3：对比两种实现

回答以下问题：
1. wait/notify 实现中，为什么用 `while` 而不是 `if` 检查条件？
2. wait/notify 实现中，为什么用 `notifyAll()` 而不是 `notify()`？
3. BlockingQueue 实现相比 wait/notify 的优势是什么？

### 验收标准

- [ ] 理解 wait() 释放锁、notify() 不释放锁
- [ ] 理解为什么用 while 而不是 if（虚假唤醒）
- [ ] 理解毒丸模式的用途
- [ ] 能说清两种实现的优缺点

### 实验记录

**wait/notify 实现**：
```
（关键输出）
```

**BlockingQueue 实现**：
```
（关键输出）
```

**思考题**：
```
1. 为什么用 while 不用 if：
2. 为什么用 notifyAll 不用 notify：
3. BlockingQueue 的优势：
```

---

## 实验 E（附加）：ThreadLocal 演示

### 实验目标

1. 理解 ThreadLocal 的线程隔离特性
2. 理解 SimpleDateFormat 线程安全问题
3. 理解内存泄漏问题和最佳实践

### 实验代码

**文件**：`code/ThreadLocalDemo.java`

### 实验步骤

```bash
javac ThreadLocalDemo.java
java ThreadLocalDemo
```

观察各实验的输出，重点关注：
- 不同线程的 ThreadLocal 值是否互相隔离？
- 线程池中不调用 remove() 会怎样？
- 调用 remove() 后是否解决了数据残留问题？

### 验收标准

- [ ] 理解 ThreadLocal 的线程隔离原理
- [ ] 理解内存泄漏的原因（弱引用 key + 强引用 value）
- [ ] 记住最佳实践：`finally { threadLocal.remove(); }`

### 实验记录

```
实验1（基本用法）：
实验2（线程隔离）：
实验3（SimpleDateFormat线程安全）：
实验4（用户上下文传递）：
实验5（内存泄漏）：
```

---

## 综合练习

### 练习1：手写线程安全的单例模式

请在不看课件的情况下，手写一个 DCL 单例模式：

```java
// 请补全代码
public class Singleton {
    // TODO: 补全实现
}
```

### 练习2：手写生产者消费者

请在不看代码的情况下，用 wait/notify 实现一个简单的生产者消费者：

```java
// 请补全代码
public class SimpleProducerConsumer {
    // TODO: 补全实现
}
```

### 练习3：排查死锁

1. 运行 `SynchronizedDemo.java`
2. 在死锁发生时，使用 `jstack` 导出线程栈
3. 在输出中找到死锁信息
4. 分析死锁原因
5. 提出修复方案

```
jstack 输出（关键部分）：

死锁原因分析：

修复方案：
```

---

## 自我评估

完成所有实验后，对照以下清单自我评估：

| 知识点 | 掌握程度 | 备注 |
|--------|---------|------|
| 线程 6 种状态 | ⬜ 完全掌握 / ⬜ 基本掌握 / ⬜ 需要复习 | |
| synchronized 原理 | ⬜ 完全掌握 / ⬜ 基本掌握 / ⬜ 需要复习 | |
| volatile 原理 | ⬜ 完全掌握 / ⬜ 基本掌握 / ⬜ 需要复习 | |
| wait/notify 机制 | ⬜ 完全掌握 / ⬜ 基本掌握 / ⬜ 需要复习 | |
| ThreadLocal 原理 | ⬜ 完全掌握 / ⬜ 基本掌握 / ⬜ 需要复习 | |
| 死锁排查 | ⬜ 完全掌握 / ⬜ 基本掌握 / ⬜ 需要复习 | |
| JMM 基础 | ⬜ 完全掌握 / ⬜ 基本掌握 / ⬜ 需要复习 | |

---

> **提示**：完成所有实验后，在 `02-学习笔记.md` 中记录你的理解和思考。
