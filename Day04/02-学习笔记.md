# Day04 学习笔记

> **学习目标**：今天的笔记目标是"**能复述、能画图、能用代码验证**"，不要抄书。  
> **参考课件**：`00-教学课件_多线程基础详解.md`

---

## 1. 进程与线程（用你自己的话解释）

### 1.1 核心区别

请用 3-5 句话说清进程和线程的区别：

```
进程：
线程：
核心区别：
```

### 1.2 为什么要用多线程？

列出你理解的至少 3 个原因：

1. 
2. 
3. 

### 1.3 多线程的挑战

列出你理解的风险：

1. 
2. 
3. 

---

## 2. 线程创建方式（代码 + 理解）

### 2.1 四种方式对比

请填写对比表格：

| 方式 | 实现要点 | 是否有返回值 | 优缺点 |
|------|---------|------------|--------|
| 继承 Thread | | | |
| 实现 Runnable | | | |
| 实现 Callable | | | |
| 线程池 | | | |

### 2.2 你认为生产环境应该用哪种？为什么？

```
我的理解：
```

---

## 3. 线程的 6 种状态

### 3.1 状态转换图

请画出线程状态转换图（参考课件第3章，用自己的方式画）：

```
NEW → RUNNABLE → ...
（请补全）
```

### 3.2 各状态详解

请逐一写清楚每种状态（参考课件第3章）：

#### NEW
- **如何进入**：
- **如何离开**：

#### RUNNABLE
- **如何进入**：
- **如何离开**：
- **注意点**：

#### BLOCKED
- **如何进入**：
- **如何离开**：
- **与 WAITING 的区别**：

#### WAITING
- **如何进入**：
- **如何离开**：

#### TIMED_WAITING
- **如何进入**：
- **如何离开**：

#### TERMINATED
- **如何进入**：

### 3.3 实验观察

运行 `code/ThreadStateDemo.java` 后，记录你观察到的状态：

```
实验1 NEW/TERMINATED：
实验2 RUNNABLE：
实验3 TIMED_WAITING：
实验4 WAITING：
实验5 BLOCKED：
实验6 完整生命周期：
```

---

## 4. 线程核心方法

### 4.1 start() vs run()

- **区别**：
- **常见错误**：

### 4.2 sleep() vs wait()

请填写对比表（这是面试高频题！）：

| 维度 | sleep() | wait() |
|------|---------|--------|
| 所属类 | | |
| 是否释放锁 | | |
| 使用条件 | | |
| 唤醒方式 | | |
| 状态变化 | | |

### 4.3 join() 的用途

- **作用**：
- **使用场景**：
- **底层原理**：

### 4.4 interrupt() 中断机制

- **interrupt() 做了什么**：
- **如何正确响应中断**：
- **为什么不用 stop()**：

---

## 5. synchronized 原理

### 5.1 三种用法

```
1. 修饰实例方法 → 锁是 ___
2. 修饰静态方法 → 锁是 ___
3. 修饰代码块 → 锁是 ___
```

### 5.2 对象头 Mark Word

请画出 Mark Word 的结构（参考课件第5.2节）：

```
（请画出不同锁状态下 Mark Word 的内容）
```

### 5.3 Monitor 机制

用自己的话解释 Monitor 的工作流程：

```
1. 线程进入 synchronized 时：
2. 如果锁被占用：
3. 调用 wait() 时：
4. 调用 notify() 时：
5. 退出 synchronized 时：
```

### 5.4 锁升级过程

请描述锁升级的 4 个阶段（这是面试高频题！）：

```
无锁 → 偏向锁 → 轻量级锁 → 重量级锁

偏向锁：
  适用场景：
  原理：
  升级条件：

轻量级锁：
  适用场景：
  原理：
  升级条件：

重量级锁：
  适用场景：
  原理：
```

### 5.5 实验观察

运行 `code/SynchronizedDemo.java` 后，记录你的观察：

```
实验1（线程不安全）：期望值=___, 实际值=___
实验2（synchronized修复）：期望值=___, 实际值=___
实验3（对象锁vs类锁）：
实验4（可重入）：
实验5（死锁）：
```

---

## 6. volatile 原理

### 6.1 volatile 的两大特性

```
1. 可见性：
2. 有序性：
3. 为什么不保证原子性：
```

### 6.2 内存屏障

请列出 volatile 插入的内存屏障：

```
volatile 写之前：___屏障
volatile 写之后：___屏障
volatile 读之后：___屏障、___屏障
```

### 6.3 MESI 协议

用自己的话解释 MESI 的 4 种状态：

```
M (Modified)：
E (Exclusive)：
S (Shared)：
I (Invalid)：
```

### 6.4 volatile 的使用场景

```
✅ 适合用的场景：
1.
2.

❌ 不适合用的场景：
1.
2.
```

### 6.5 实验观察

运行 `code/VolatileDemo.java` 后，记录你的观察：

```
实验1（可见性问题）：
实验2（volatile修复）：
实验3（不保证原子性）：期望值=___, 实际值=___
实验4（正确使用场景）：
```

---

## 7. Java 内存模型 JMM

### 7.1 主内存与工作内存

请画出 JMM 的结构图：

```
（参考课件第7章画出主内存和工作内存的关系）
```

### 7.2 happens-before 规则

请列出你记住的 happens-before 规则（至少 4 条）：

1. 
2. 
3. 
4. 

### 7.3 实际应用

举一个你理解的 happens-before 应用例子：

```
（例如 volatile 规则 + 传递性 保证可见性的例子）
```

---

## 8. ThreadLocal

### 8.1 ThreadLocal 的作用

```
一句话概括：
```

### 8.2 内存泄漏问题

```
原因：
  - Entry 的 key 是___引用
  - Entry 的 value 是___引用
  - 当 ThreadLocal 被 GC 后：

解决方案：
```

### 8.3 使用场景

列出你了解的使用场景：

1. 
2. 
3. 

### 8.4 实验观察

运行 `code/ThreadLocalDemo.java` 后，记录你的观察：

```
实验1（基本用法）：
实验2（线程隔离）：
实验3（SimpleDateFormat）：
实验4（用户上下文）：
实验5（内存泄漏）：
```

---

## 9. 线程安全

### 9.1 三种实现方式

```
1. 互斥同步：
2. 非阻塞同步：
3. 无同步方案：
```

### 9.2 synchronized vs ReentrantLock

| 维度 | synchronized | ReentrantLock |
|------|-------------|---------------|
| 实现层面 | | |
| 锁释放 | | |
| 可中断 | | |
| 公平性 | | |
| 推荐度 | | |

---

## 10. 死锁

### 10.1 四个必要条件

1. 
2. 
3. 
4. 

### 10.2 排查方法

```
方法1：jstack
  命令：
  关键输出：

方法2：图形化工具
  工具名：
  操作步骤：
```

### 10.3 避免策略

列出你了解的避免死锁策略：

1. 
2. 
3. 

---

## 11. 5 分钟复述稿（面试式）

用 5 分钟讲清楚"多线程基础"，要求：
- 先总览，再逐一解释，再给 1 个故障案例

**我的复述稿**：

```
【总览】
Java 多线程涉及线程创建、生命周期、同步机制、内存模型四大板块...

【核心知识点】
1. 线程创建：...
2. 线程状态：...
3. synchronized：...
4. volatile：...
5. JMM：...
6. ThreadLocal：...
7. 线程安全：...
8. 死锁：...

【故障案例】
我遇到过一个...的问题...
```

---

## 12. 学习总结与疑问

### 12.1 今天学到的核心知识点

1. 
2. 
3. 
4. 
5. 

### 12.2 还有疑问的地方

1. 
2. 

### 12.3 下一步学习计划

- [ ] 复习课件第12章的检查清单
- [ ] 准备 Day05 的学习

---

> **提示**：完成笔记后，对照课件第 12.1 节的检查清单进行自我验收。
