# Day06 实验与练习

> **目标**：通过动手实验，验证线程池工作流程、拒绝策略、手写线程池、ForkJoinPool 等核心知识点。  
> **参考课件**：`00-教学课件_线程池原理与实战详解.md`

---

## 实验A：观察不同参数配置的线程池行为

### 实验目标

- 理解线程池 7 个核心参数的实际效果
- 观察任务提交 → 核心线程 → 队列 → 最大线程 → 拒绝的完整流程
- 理解 execute vs submit 的异常处理区别
- 对比 shutdown() vs shutdownNow() 的行为

### 实验步骤

#### 步骤 1：运行 ThreadPoolDemo.java

```bash
cd Day06/code
javac ThreadPoolDemo.java
java ThreadPoolDemo
```

#### 步骤 2：观察演示1（线程池工作流程）

运行后，关注以下输出：

1. 任务1、2 应该各创建一个核心线程执行
2. 任务3、4 应该进入队列排队
3. 任务5、6 应该创建非核心线程执行
4. 任务7 应该被拒绝（AbortPolicy 抛异常）

**请记录**：

| 任务编号 | 实际行为（创建线程/入队/拒绝） | 是否符合预期 |
|---------|--------------------------|:----------:|
| 任务1 | | |
| 任务2 | | |
| 任务3 | | |
| 任务4 | | |
| 任务5 | | |
| 任务6 | | |
| 任务7 | | |

#### 步骤 3：观察演示2（4种拒绝策略）

关注每种策略下 4 个任务的完成数：

| 策略 | 完成任务数/4 | 行为描述 |
|------|:----------:|---------|
| AbortPolicy | | |
| CallerRunsPolicy | | |
| DiscardPolicy | | |
| DiscardOldestPolicy | | |

#### 步骤 4：观察演示3（execute vs submit）

**请回答**：
- execute 方式，异常如何传播？线程是否终止？
  - 
- submit 方式，不调用 future.get() 能否感知异常？
  - 
- 调用 future.get() 后能否捕获到异常？捕获到的是什么类型？
  - 

#### 步骤 5：观察演示4（shutdown vs shutdownNow）

**请回答**：
- shutdown() 后，已提交到队列的任务是否会执行？
  - 
- shutdownNow() 返回了多少个未执行的任务？
  - 
- shutdownNow() 后，正在执行的任务发生了什么？
  - 

### 扩展实验

尝试修改 ThreadPoolDemo.java 中的参数，观察行为变化：

1. 将 `corePoolSize` 改为 4、`maximumPoolSize` 改为 4，观察是否还有"入队"行为
2. 将队列改为 `SynchronousQueue`，观察行为变化
3. 将队列改为 `LinkedBlockingQueue()`（无界），观察是否触发拒绝策略
4. 调用 `pool.prestartAllCoreThreads()`，观察初始线程数的变化

### 验收标准

- [ ] 能正确预测给定参数下每个任务的去向（核心线程/队列/非核心线程/拒绝）
- [ ] 能说出 4 种拒绝策略的实际效果差异
- [ ] 能解释 execute 和 submit 的异常处理区别
- [ ] 能说出 shutdown 和 shutdownNow 的行为差异

---

## 实验B：4种拒绝策略效果对比

### 实验目标

- 深入理解每种拒绝策略的触发条件和行为
- 实现自定义拒绝策略
- 理解 CallerRunsPolicy 的反压（Back Pressure）效果

### 实验步骤

#### 步骤 1：运行 RejectPolicyDemo.java

```bash
cd Day06/code
javac RejectPolicyDemo.java
java RejectPolicyDemo
```

#### 步骤 2：观察基础演示

观察 `corePoolSize=1, maximumPoolSize=2, queueCapacity=2` 配置下，提交 8 个任务的行为。

线程池最大处理能力 = maximumPoolSize + queueCapacity = 2 + 2 = 4 个任务同时处理。

**请记录每种策略的表现**：

| 策略 | 成功提交数 | 拒绝数 | 拒绝时的现象 |
|------|:--------:|:-----:|------------|
| AbortPolicy | | | |
| CallerRunsPolicy | | | |
| DiscardPolicy | | | |
| DiscardOldestPolicy | | | |

#### 步骤 3：观察 CallerRunsPolicy 的反压效果

注意 CallerRunsPolicy 演示中：
- 主线程（main）是否也在执行任务？
- 当主线程执行任务时，是否暂停了任务提交？
- 最终完成的任务数是否多于其他策略？

**请回答**：
- CallerRunsPolicy 如何实现反压（降速）的？
  - 
- 为什么 CallerRunsPolicy 不会丢任务？
  - 

#### 步骤 4：观察自定义拒绝策略

RejectPolicyDemo 中包含一个自定义拒绝策略示例（记录日志+计数），观察其输出。

**请回答**：
- 生产环境中，你会怎么设计自定义拒绝策略？
  - 

#### 步骤 5：补充实验（手动修改代码）

1. 修改线程池参数为 `core=2, max=4, queue=3`，重新运行，观察变化
2. 在 DiscardOldestPolicy 测试中，打印被丢弃的任务信息
3. 实现一个"带超时重试"的拒绝策略：用 `queue.offer(task, 2, TimeUnit.SECONDS)` 等待入队

### 验收标准

- [ ] 能准确描述每种拒绝策略的行为
- [ ] 能解释 CallerRunsPolicy 的反压机制
- [ ] 能实现至少一种自定义拒绝策略
- [ ] 能根据业务场景选择合适的拒绝策略

---

## 实验C：手写简易线程池

### 实验目标

- 理解线程池的核心工作原理
- 掌握 Worker 线程的循环执行机制
- 理解任务队列的缓冲作用
- 实现拒绝策略和优雅关闭

### 实验步骤

#### 步骤 1：运行 SimpleThreadPool.java

```bash
cd Day06/code
javac SimpleThreadPool.java
java SimpleThreadPool
```

#### 步骤 2：观察测试1（基本功能）

配置 `corePoolSize=3, queueCapacity=5`，提交 8 个任务。

**请回答**：
- 线程池启动时创建了几个 Worker？
  - 
- 8 个任务中，有几个立即被 Worker 取走执行？有几个在队列中等待？
  - 
- 所有任务是否都成功完成？
  - 

#### 步骤 3：观察测试2（拒绝策略）

配置 `corePoolSize=2, queueCapacity=2`，提交 6 个任务。

**请回答**：
- 线程池的最大处理能力是多少？
  - （提示：Worker 正在执行的 + 队列中等待的）
- 哪些任务被拒绝了？
  - 

#### 步骤 4：观察测试3（CallerRuns 策略）

**请回答**：
- 被拒绝的任务在哪个线程上执行？
  - 
- 为什么最终所有 6 个任务都完成了？
  - 

#### 步骤 5：理解源码

阅读 SimpleThreadPool.java 源码，回答以下问题：

1. Worker 的核心循环逻辑是什么？
   - 
2. 为什么用 `poll(1, TimeUnit.SECONDS)` 而不是 `take()`？
   - 
3. `isStopped` 变量的作用是什么？
   - 
4. 为什么 `while` 条件是 `!isStopped || !taskQueue.isEmpty()`？
   - 

#### 步骤 6：扩展挑战

在 SimpleThreadPool 的基础上，尝试添加以下功能：

1. **非核心线程**：当队列满时，动态创建额外的 Worker（不超过 maximumPoolSize），空闲后回收
2. **submit 方法**：返回 Future，支持获取任务结果
3. **监控方法**：getActiveCount()、getCompletedTaskCount() 等
4. **钩子方法**：beforeExecute、afterExecute

### 验收标准

- [ ] 能完整运行 SimpleThreadPool 的 3 个测试
- [ ] 能用自己的话描述 Worker 线程的循环执行机制
- [ ] 能解释线程复用的本质（线程不销毁，循环取任务）
- [ ] 能说出 SimpleThreadPool 与 ThreadPoolExecutor 的差距

---

## 实验D：ForkJoinPool 并行计算

### 实验目标

- 理解 Fork/Join 分治思想
- 掌握 RecursiveTask（有返回值）和 RecursiveAction（无返回值）的使用
- 观察工作窃取算法的效果
- 对比 ForkJoinPool 与单线程的性能差异

### 实验步骤

#### 步骤 1：运行 ForkJoinDemo.java

```bash
cd Day06/code
javac ForkJoinDemo.java
java ForkJoinDemo
```

#### 步骤 2：观察示例1（RecursiveTask 大数组求和）

**请记录**：
- ForkJoin 求和结果：________
- 数学公式验证结果：________
- 两者是否一致：________

#### 步骤 3：观察示例2（RecursiveAction 并行排序）

**请记录**：
- 排序耗时：________ms
- 排序是否正确：________

#### 步骤 4：观察示例3（性能对比）

**请记录**：

| 方式 | 数组大小 | 求和结果 | 耗时 |
|------|---------|---------|------|
| 单线程 | 1 亿 | | ms |
| ForkJoinPool | 1 亿 | | ms |

- 加速比：________x
- 你的 CPU 核心数：________（通过 `Runtime.getRuntime().availableProcessors()` 获取）

**请回答**：
- 加速比是否接近 CPU 核心数？为什么？
  - 
- 如果数组很小（如 100 个元素），ForkJoin 会更快吗？为什么？
  - 

#### 步骤 5：观察示例4（工作窃取观察）

**请记录**：
- 窃取次数（getStealCount）：________
- 不同任务是否在不同线程上执行？
  - 

#### 步骤 6：理解代码

阅读 ForkJoinDemo.java 源码，回答以下问题：

1. SumTask 的 `THRESHOLD` 是做什么用的？设为多少合适？
   - 
2. 为什么是 `leftTask.fork() + rightTask.compute()` 而不是两个都 `fork()`？
   - 
3. `invokeAll(left, right)` 和 `left.fork() + right.compute()` 有什么区别？
   - 
4. ForkJoinPool 的默认并行度是多少？为什么？
   - 

#### 步骤 7：扩展实验

1. **修改阈值**：将 THRESHOLD 改为 100、1000000，对比性能变化
2. **尝试其他任务**：用 RecursiveAction 实现并行的数组元素加倍（每个元素 × 2）
3. **与 parallelStream 对比**：用 Java 8 的 `Arrays.stream(array).parallel().sum()` 对比性能
4. **观察 commonPool**：打印 `ForkJoinPool.commonPool()` 的信息

### 验收标准

- [ ] 能成功运行所有 4 个示例
- [ ] 能解释 Fork/Join 的分治流程
- [ ] 能区分 RecursiveTask 和 RecursiveAction 的使用场景
- [ ] 能解释工作窃取算法的优势
- [ ] 能说出 ForkJoinPool 适合和不适合的场景

---

## 综合思考题

完成所有实验后，回答以下思考题：

### 1. 线程池参数设计

假设你在开发一个电商系统，有以下两类任务：
- **订单处理**：涉及数据库读写、调用支付接口（IO 密集型）
- **价格计算**：纯 CPU 计算，根据优惠规则计算最终价格

服务器有 8 核 CPU，请设计这两个线程池的参数配置，并说明理由。

```
订单处理线程池：
- corePoolSize = ?
- maximumPoolSize = ?
- keepAliveTime = ?
- workQueue = ?（类型和容量）
- handler = ?
- 理由：

价格计算线程池：
- corePoolSize = ?
- maximumPoolSize = ?
- keepAliveTime = ?
- workQueue = ?
- handler = ?
- 理由：
```

### 2. 故障排查

线上报告 OOM，dump 分析发现大量 `java.util.concurrent.LinkedBlockingQueue$Node` 对象。请分析：
- 可能的原因是什么？
  - 
- 如何排查？
  - 
- 如何修复？
  - 

### 3. 自定义线程池

如果让你设计一个支持**优先级**的线程池，需要考虑哪些问题？

```
（请写出你的设计思路）
```

---

> **提示**：完成所有实验后，回到 `02-学习笔记.md` 记录你的学习收获和思考。
