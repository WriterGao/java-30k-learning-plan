# Day03 实验与练习

> **参考课件**：`00-教学课件_JVM调优实战详解.md`  
> **实验代码**：`code/` 目录

---

## 0. 环境准备

### 必需工具

- **JDK**：建议 JDK 11+（部分工具命令在不同版本有差异）
- **命令行工具**：jps、jstat、jinfo、jmap、jstack、jcmd（JDK 自带）
- **可选图形化工具**：
  - jconsole（JDK 自带）
  - jvisualvm（JDK 8 自带，JDK 9+ 需独立下载）
  - MAT（Eclipse Memory Analyzer）：https://eclipse.dev/mat/
  - Arthas（阿里巴巴开源诊断工具）：https://arthas.aliyun.com/

### 工具检查

```bash
# 检查 JDK 版本
java -version

# 检查命令行工具是否可用
jps -l
jstat -help
jmap -help
jstack -help
jcmd -help

# 如果使用 JDK 9+，GC 日志参数格式不同
# JDK 8:  -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:gc.log
# JDK 9+: -Xlog:gc*:file=gc.log:time,uptime,level,tags
```

> **备注**：不同 JDK 版本的工具和参数可能有差异，这是正常的。本实验以 JDK 11+ 为主，如有差异请查阅对应版本文档。

---

## 1. 实验 A：使用 jstat 监控 GC 情况（必须完成）

### 实验目标

熟练使用 `jstat` 命令实时监控 JVM 的 GC 活动，理解各指标含义。

### 实验步骤

#### 步骤1：启动目标程序

```bash
cd Day03/code
javac CPUHighDemo.java
java -Xms64m -Xmx64m -verbose:gc CPUHighDemo 2
```

> 使用场景2（频繁 Full GC），便于观察 GC 活动

#### 步骤2：在另一个终端使用 jstat 监控

```bash
# 1. 找到进程 PID
jps -l

# 2. 监控 GC 概况（每秒打印一次，持续观察）
jstat -gc <pid> 1000

# 3. 监控 GC 统计信息
jstat -gcutil <pid> 1000

# 4. 监控 GC 原因
jstat -gccause <pid> 1000

# 5. 监控新生代
jstat -gcnew <pid> 1000

# 6. 监控老年代
jstat -gcold <pid> 1000
```

#### 步骤3：理解 jstat -gc 输出

```
 S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    ...
5120.0 5120.0  0.0   4096.0  33280.0  15360.0   87552.0    65432.0  ...    ...   ...
```

| 列名 | 含义 | 单位 |
|------|------|------|
| S0C | Survivor 0 区容量 | KB |
| S1C | Survivor 1 区容量 | KB |
| S0U | Survivor 0 区已使用 | KB |
| S1U | Survivor 1 区已使用 | KB |
| EC | Eden 区容量 | KB |
| EU | Eden 区已使用 | KB |
| OC | 老年代容量 | KB |
| OU | 老年代已使用 | KB |
| MC | 元空间容量 | KB |
| MU | 元空间已使用 | KB |
| YGC | Young GC 次数 | 次 |
| YGCT | Young GC 总耗时 | 秒 |
| FGC | Full GC 次数 | 次 |
| FGCT | Full GC 总耗时 | 秒 |
| GCT | GC 总耗时 | 秒 |

### 记录项（写在 `02-学习笔记.md`）

- **你观察到的 GC 频率**：
  - YGC 变化速率：每 ___ 秒增加一次
  - FGC 变化速率：每 ___ 秒增加一次
- **各区域使用率**：
  - Eden 区使用率范围：___% ~ ___%
  - 老年代使用率趋势：
- **你的分析**：
  - GC 频率是否正常？
  - 老年代是否在持续增长？（内存泄漏的信号）

### 验收标准

- [ ] 能正确使用 jstat -gc 和 jstat -gcutil 命令
- [ ] 能解读输出中每一列的含义
- [ ] 能根据 GC 数据判断是否存在内存问题

---

## 2. 实验 B：使用 jmap 导出堆转储并用 MAT 分析（建议完成）

### 实验目标

掌握使用 `jmap` 导出堆转储文件，并使用 MAT（或 jvisualvm）分析内存泄漏。

### 实验代码

**文件**：`code/MemoryLeakDemo.java`

### 实验步骤

#### 步骤1：启动内存泄漏程序

```bash
cd Day03/code
javac MemoryLeakDemo.java
java -Xms128m -Xmx128m \
     -XX:+HeapDumpOnOutOfMemoryError \
     -XX:HeapDumpPath=./heap_leak.hprof \
     -verbose:gc \
     MemoryLeakDemo
```

#### 步骤2：在 OOM 之前手动导出堆转储

在另一个终端执行：

```bash
# 找到 PID
jps -l

# 方法1：使用 jmap 导出堆转储
jmap -dump:format=b,file=heap_before_oom.hprof <pid>

# 方法2：使用 jcmd 导出堆转储（推荐）
jcmd <pid> GC.heap_dump heap_before_oom.hprof

# 查看堆内存中对象统计（不导出完整转储）
jmap -histo <pid> | head -20
```

#### 步骤3：使用 MAT 分析堆转储

1. **下载 MAT**：https://eclipse.dev/mat/
2. **打开堆转储文件**：File → Open Heap Dump → 选择 `.hprof` 文件
3. **分析步骤**：
   - 查看 **Leak Suspects Report**（泄漏疑点报告）
   - 查看 **Dominator Tree**（支配树）：找出占用内存最大的对象
   - 查看 **Top Consumers**：找出内存消耗最多的类
   - 查看 **Histogram**：按类统计对象数量和大小
4. **定位泄漏**：
   - 找到 `byte[]` 数组占用了大量内存
   - 通过 GC Roots 路径追溯，发现被 `LEAK_LIST`（静态 ArrayList）持有

#### 步骤4：如果没有 MAT，使用 jvisualvm 替代

```bash
jvisualvm
# 文件 → 载入 → 选择 .hprof 文件
# 查看"类"标签：找出实例最多的类
# 查看"摘要"标签：基本信息
```

### 记录项（写在 `02-学习笔记.md`）

- **堆转储文件大小**：
- **MAT 分析发现**：
  - 最大的对象是什么？
  - GC Root 路径是什么？
  - 泄漏原因是什么？
- **修复方案**：

### 验收标准

- [ ] 能使用 jmap 或 jcmd 导出堆转储
- [ ] 能使用 MAT 或 jvisualvm 打开并分析堆转储
- [ ] 能定位到内存泄漏的根本原因

---

## 3. 实验 C：使用 jstack 排查死锁（必须完成）

### 实验目标

使用 `jstack` 排查线程死锁，理解线程状态和锁信息。

### 实验代码

**文件**：`code/DeadLockDemo.java`

### 实验步骤

#### 步骤1：启动死锁程序

```bash
cd Day03/code
javac DeadLockDemo.java
java DeadLockDemo
```

程序会在 3 秒后提示发生了死锁。

#### 步骤2：使用 jstack 查看线程信息

```bash
# 找到 PID
jps -l

# 打印线程堆栈
jstack <pid>

# 或保存到文件
jstack <pid> > thread_dump.txt
```

#### 步骤3：分析 jstack 输出

在 jstack 输出的**最后**，会看到死锁信息：

```
Found one Java-level deadlock:
=============================
"Thread-B-持有lockB-等待lockA":
  waiting to lock monitor 0x... (object 0x..., a java.lang.Object),
  which is held by "Thread-A-持有lockA-等待lockB"
"Thread-A-持有lockA-等待lockB":
  waiting to lock monitor 0x... (object 0x..., a java.lang.Object),
  which is held by "Thread-B-持有lockB-等待lockA"
```

**需要关注的线程状态**：

| 状态 | 含义 |
|------|------|
| `RUNNABLE` | 正在运行或准备运行 |
| `BLOCKED` | 等待获取监视器锁 |
| `WAITING` | 无限期等待（wait/join/park） |
| `TIMED_WAITING` | 有时限的等待（sleep/wait(timeout)） |

#### 步骤4：使用 jcmd 查看线程信息

```bash
jcmd <pid> Thread.print
```

### 记录项（写在 `02-学习笔记.md`）

- **死锁涉及的线程**：
- **每个线程持有的锁**：
- **每个线程等待的锁**：
- **死锁的原因分析**：
- **如何避免死锁**（至少写 3 种方法）：

### 验收标准

- [ ] 能使用 jstack 命令打印线程堆栈
- [ ] 能在输出中找到死锁信息
- [ ] 能分析死锁的原因
- [ ] 能说出至少 3 种避免死锁的方法

---

## 4. 实验 D：对 Spring Boot 项目进行 JVM 调优（进阶选做）

### 实验目标

将所学的 JVM 调优知识应用到实际的 Spring Boot 项目中。

### 实验步骤

#### 步骤1：准备一个 Spring Boot 项目

如果你没有现成的项目，可以使用 Spring Initializr 创建一个简单的 Web 项目：

```bash
# 使用 curl 快速创建（或访问 https://start.spring.io/）
curl https://start.spring.io/starter.zip \
  -d type=maven-project \
  -d language=java \
  -d javaVersion=17 \
  -d dependencies=web \
  -d name=jvm-tuning-demo \
  -o jvm-tuning-demo.zip
unzip jvm-tuning-demo.zip -d jvm-tuning-demo
```

#### 步骤2：使用默认参数启动并记录基线

```bash
# 默认参数启动
java -jar your-app.jar

# 记录基线数据
jps -l
jstat -gc <pid> 1000
jinfo -flags <pid>
```

**记录基线数据**：
- 默认堆大小：
- GC 收集器：
- 启动时间：
- GC 频率：

#### 步骤3：应用调优参数

```bash
# 4C8G 服务器推荐参数（参考课件第9章）
java \
  -Xms4g -Xmx4g \
  -Xmn2g \
  -XX:MetaspaceSize=256m \
  -XX:MaxMetaspaceSize=256m \
  -XX:+UseG1GC \
  -XX:MaxGCPauseMillis=200 \
  -XX:+HeapDumpOnOutOfMemoryError \
  -XX:HeapDumpPath=/tmp/heapdump.hprof \
  -Xlog:gc*:file=gc.log:time,uptime,level,tags \
  -jar your-app.jar
```

#### 步骤4：对比调优前后

| 指标 | 调优前 | 调优后 |
|------|-------|-------|
| 堆大小 | | |
| GC 收集器 | | |
| YGC 频率 | | |
| FGC 频率 | | |
| 平均 GC 暂停时间 | | |
| 应用响应时间 | | |

#### 步骤5：压测验证（可选）

如果有条件，使用 wrk 或 ab 进行简单压测：

```bash
# 安装 wrk（macOS）
brew install wrk

# 压测
wrk -t4 -c100 -d30s http://localhost:8080/api/test

# 压测期间监控 GC
jstat -gcutil <pid> 1000
```

### 记录项（写在 `02-学习笔记.md`）

- **调优前后对比数据**：
- **你调整了哪些参数？每个参数的调整理由？**：
- **调优效果如何？是否达到预期？**：

### 验收标准

- [ ] 能为 Spring Boot 项目配置合理的 JVM 参数
- [ ] 能使用 jstat 监控应用运行时的 GC 情况
- [ ] 能对比调优前后的 GC 指标变化
- [ ] 能解释每个参数的设置理由

---

## 5. 今日验收（完成即达标）

### 基础验收

- [ ] 能使用 jps/jstat/jstack/jmap/jcmd 基本命令
- [ ] 完成实验 A（jstat 监控 GC）并记录数据
- [ ] 完成实验 C（jstack 排查死锁）并分析原因
- [ ] 能说出 CPU 飙高的排查流程

### 进阶验收

- [ ] 完成实验 B（jmap + MAT 分析内存泄漏）
- [ ] 完成实验 D（Spring Boot JVM 调优）
- [ ] 能写出生产环境 JVM 参数模板并解释每个参数
- [ ] 能回答课件第 11 章的面试高频问题

---

## 6. 常见问题

### Q1: jmap 报错 "Unable to open socket file"？

**A**: 
- 确认目标进程的 owner 和当前用户一致
- 尝试使用 `sudo jmap` 或 `jcmd`
- JDK 9+ 推荐使用 `jcmd` 替代 `jmap`

### Q2: jstack 输出太长看不过来？

**A**: 
- 保存到文件：`jstack <pid> > thread_dump.txt`
- 搜索关键字：`grep -i "deadlock" thread_dump.txt`
- 搜索 BLOCKED 线程：`grep "BLOCKED" thread_dump.txt`
- 使用在线分析工具：https://fastthread.io/

### Q3: MAT 打开大文件很慢？

**A**: 
- 调大 MAT 自身的 JVM 参数：编辑 `MemoryAnalyzer.ini`
- 设置 `-Xmx4g` 或更大
- 也可以先用 `jmap -histo` 看概况，再决定是否需要 MAT

### Q4: macOS 上 top 命令不显示线程？

**A**: 
- macOS 上使用 `ps -M -p <pid>` 查看线程
- 或使用 Arthas 的 `thread` 命令更方便

---

> **提示**：完成实验后，务必在 `02-学习笔记.md` 中记录你的观察结果和思考。
