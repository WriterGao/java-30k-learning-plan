# Day12 实验与练习

> **实验目标**：通过动手编码验证设计模式结构型模式的核心概念  
> **参考课件**：`00-教学课件_设计模式之结构型模式详解.md`  
> **实验代码**：`code/` 目录

---

## 实验A：实现适配器模式（对象适配器）

### 实验目标

1. 理解适配器模式解决的问题（接口不兼容）
2. 实现对象适配器模式
3. 理解适配器模式与装饰器模式的区别

### 实验步骤

#### Step 1：运行适配器模式演示

```bash
cd Day12/code
javac AdapterDemo.java
java AdapterDemo
```

#### Step 2：观察输出

**观察要点**：
- 适配器如何将不兼容的接口转换为目标接口
- 对象适配器如何通过组合实现适配
- 客户端如何使用统一的接口调用不同的实现

#### Step 3：自己动手

请实现一个适配器，将第三方支付接口适配到你的系统：

```java
// 目标接口（你的系统需要的接口）
public interface PaymentService {
    void pay(double amount);
}

// 第三方支付接口（不兼容）
public class AlipaySDK {
    public void alipay(double money) {
        System.out.println("支付宝支付: " + money);
    }
}

public class WechatPaySDK {
    public void wechatPay(double money) {
        System.out.println("微信支付: " + money);
    }
}
```

要求：
1. 创建 `AlipayAdapter` 和 `WechatPayAdapter` 适配器
2. 客户端可以通过统一的 `PaymentService` 接口调用不同的支付方式

#### Step 4：思考题

1. 适配器模式和装饰器模式有什么区别？
2. 什么时候用适配器模式？什么时候用装饰器模式？
3. JDK 中的 `InputStreamReader` 是适配器模式吗？为什么？

### 验收标准

- [ ] 能运行 AdapterDemo
- [ ] 能手写对象适配器模式
- [ ] 能说清楚适配器和装饰器的区别
- [ ] 理解适配器模式的适用场景

---

## 实验B：实现桥接模式（避免类爆炸）

### 实验目标

1. 理解桥接模式解决的问题（类爆炸）
2. 实现桥接模式，将抽象与实现分离
3. 对比桥接模式和继承方式的区别

### 实验步骤

#### Step 1：运行桥接模式演示

```bash
cd Day12/code
javac BridgeDemo.java
java BridgeDemo
```

#### Step 2：观察输出

**观察要点**：
- 桥接模式如何通过组合避免类爆炸
- 抽象部分（形状）和实现部分（颜色）如何独立变化
- 新增形状或颜色时，不需要创建大量新类

#### Step 3：自己动手

请用桥接模式实现一个消息发送系统：

```java
// 抽象部分：消息类型
public abstract class Message {
    protected MessageSender sender; // 桥接
    // ...
}

// 实现部分：发送方式
public interface MessageSender {
    void send(String message);
}
```

要求：
- 消息类型：文本消息、图片消息、视频消息
- 发送方式：邮件发送、短信发送、微信发送
- 使用桥接模式，避免为每种组合创建类（3 × 3 = 9 个类）

#### Step 4：思考题

1. 如果使用继承方式，需要创建多少个类？
2. 使用桥接模式后，需要创建多少个类？
3. 桥接模式的核心思想是什么？（一句话概括）

### 验收标准

- [ ] 能运行 BridgeDemo
- [ ] 能手写桥接模式
- [ ] 能解释桥接模式如何避免类爆炸
- [ ] 理解桥接模式的适用场景

---

## 实验C：实现组合模式（文件系统）

### 实验目标

1. 理解组合模式解决的问题（树形结构）
2. 实现组合模式，统一处理单个对象和组合对象
3. 理解透明式和安全式的区别

### 实验步骤

#### Step 1：运行组合模式演示

```bash
cd Day12/code
javac CompositeDemo.java
java CompositeDemo
```

#### Step 2：观察输出

**观察要点**：
- 组合模式如何形成树形结构
- 如何统一处理文件（叶子节点）和文件夹（组合节点）
- 递归显示树形结构的实现

#### Step 3：自己动手

请用组合模式实现一个组织架构系统：

```java
// 抽象组件
public abstract class OrganizationComponent {
    protected String name;
    // ...
}

// 叶子节点：员工
public class Employee extends OrganizationComponent {
    // ...
}

// 组合节点：部门
public class Department extends OrganizationComponent {
    private List<OrganizationComponent> children = new ArrayList<>();
    // ...
}
```

要求：
1. 部门可以包含员工和子部门
2. 统一显示组织架构（递归）
3. 客户端不需要区分是员工还是部门

#### Step 4：思考题

1. 组合模式和装饰器模式有什么区别？
2. 透明式和安全式各有什么优缺点？
3. 什么时候用组合模式？

### 验收标准

- [ ] 能运行 CompositeDemo
- [ ] 能手写组合模式
- [ ] 能画图说明组合模式的树形结构
- [ ] 理解组合模式的适用场景

---

## 实验D：实现装饰器模式（咖啡加料）

### 实验目标

1. 理解装饰器模式解决的问题（动态扩展功能）
2. 实现装饰器模式，动态组合功能
3. 理解装饰器模式与继承的区别

### 实验步骤

#### Step 1：运行装饰器模式演示

```bash
cd Day12/code
javac DecoratorDemo.java
java DecoratorDemo
```

#### Step 2：观察输出

**观察要点**：
- 装饰器如何通过链式调用动态组合功能
- 如何避免为每种组合创建类
- 装饰器和被装饰者实现同一接口

#### Step 3：自己动手

请用装饰器模式实现一个数据流处理系统：

```java
// 抽象组件
public interface DataStream {
    String read();
    void write(String data);
}

// 具体组件
public class FileStream implements DataStream {
    // ...
}

// 装饰器：添加缓冲功能
public class BufferedStream implements DataStream {
    protected DataStream stream;
    // ...
}

// 装饰器：添加加密功能
public class EncryptedStream implements DataStream {
    protected DataStream stream;
    // ...
}
```

要求：
1. 可以动态组合缓冲和加密功能
2. 可以任意顺序组合（缓冲+加密 或 加密+缓冲）

#### Step 4：思考题

1. 装饰器模式和代理模式有什么区别？
2. Java IO 中的 `BufferedInputStream` 是装饰器模式吗？
3. 什么时候用装饰器模式？什么时候用代理模式？

### 验收标准

- [ ] 能运行 DecoratorDemo
- [ ] 能手写装饰器模式
- [ ] 能说清楚装饰器和代理的区别
- [ ] 理解装饰器模式的适用场景

---

## 实验E：实现外观模式（家庭影院）

### 实验目标

1. 理解外观模式解决的问题（简化复杂子系统）
2. 实现外观模式，为复杂子系统提供简单接口
3. 理解外观模式与适配器模式的区别

### 实验步骤

#### Step 1：运行外观模式演示

```bash
cd Day12/code
javac FacadeDemo.java
java FacadeDemo
```

#### Step 2：观察输出

**观察要点**：
- 外观如何封装多个子系统的复杂操作
- 客户端如何通过简单接口使用复杂子系统
- 外观如何隐藏子系统的复杂性

#### Step 3：自己动手

请用外观模式实现一个数据库操作外观：

```java
// 子系统组件
public class ConnectionManager {
    public Connection getConnection() { /* ... */ }
    public void closeConnection(Connection conn) { /* ... */ }
}

public class StatementExecutor {
    public ResultSet executeQuery(Connection conn, String sql) { /* ... */ }
}

public class ResultSetProcessor {
    public List<Map<String, Object>> process(ResultSet rs) { /* ... */ }
}

// 外观类
public class DatabaseFacade {
    // 提供一个简单的 query 方法，封装所有复杂操作
    public List<Map<String, Object>> query(String sql) {
        // 1. 获取连接
        // 2. 执行查询
        // 3. 处理结果集
        // 4. 关闭连接
        // 5. 返回结果
    }
}
```

要求：
1. 外观类封装所有数据库操作的复杂步骤
2. 客户端只需要调用一个简单的方法

#### Step 4：思考题

1. 外观模式和适配器模式有什么区别？
2. Spring 的 `JdbcTemplate` 是外观模式吗？为什么？
3. 什么时候用外观模式？

### 验收标准

- [ ] 能运行 FacadeDemo
- [ ] 能手写外观模式
- [ ] 能说清楚外观和适配器的区别
- [ ] 理解外观模式的适用场景

---

## 实验F：实现享元模式（围棋棋子）

### 实验目标

1. 理解享元模式解决的问题（大量相似对象）
2. 实现享元模式，共享内部状态
3. 理解内部状态和外部状态的区别

### 实验步骤

#### Step 1：运行享元模式演示

```bash
cd Day12/code
javac FlyweightDemo.java
java FlyweightDemo
```

#### Step 2：观察输出

**观察要点**：
- 享元工厂如何缓存和复用对象
- 内部状态（颜色）如何共享
- 外部状态（位置）如何由客户端传入
- 创建的对象数量是否远少于使用次数

#### Step 3：自己动手

请用享元模式实现一个字符渲染系统：

```java
// 享元接口
public interface Character {
    void display(int x, int y, int fontSize);
}

// 具体享元（共享字体、大小等内部状态）
public class ConcreteCharacter implements Character {
    private final char charValue; // 内部状态（共享）
    // ...
}

// 享元工厂
public class CharacterFactory {
    private static final Map<Character, Character> characters = new HashMap<>();
    // ...
}
```

要求：
1. 相同字符共享同一个对象
2. 位置、字体大小等作为外部状态传入

#### Step 4：思考题

1. String 常量池是享元模式吗？为什么？
2. Integer 缓存（-128 到 127）是享元模式吗？
3. 什么时候用享元模式？

### 验收标准

- [ ] 能运行 FlyweightDemo
- [ ] 能手写享元模式
- [ ] 能说清楚内部状态和外部状态的区别
- [ ] 理解享元模式的适用场景

---

## 实验G：实现代理模式（静态代理、JDK 动态代理、CGLIB）

### 实验目标

1. 理解代理模式的三种实现方式
2. 实现静态代理、JDK 动态代理、CGLIB
3. 理解 JDK 动态代理和 CGLIB 的区别

### 实验步骤

#### Step 1：运行代理模式演示

```bash
cd Day12/code
javac ProxyDemo.java
java ProxyDemo
```

#### Step 2：观察输出

**观察要点**：
- 静态代理如何为每个方法添加增强
- JDK 动态代理如何通过 InvocationHandler 统一处理
- CGLIB 如何通过继承创建代理
- 三种代理方式的区别

#### Step 3：自己动手

请实现三种代理方式：

1. **静态代理**：为 `UserService` 添加日志功能
2. **JDK 动态代理**：为 `UserService` 添加性能监控
3. **CGLIB**：为没有接口的 `UserService` 添加事务管理

```java
// 接口
public interface UserService {
    void saveUser(User user);
    void deleteUser(Long id);
}

// 实现类
public class UserServiceImpl implements UserService {
    // ...
}
```

要求：
1. 静态代理：手动创建代理类
2. JDK 动态代理：使用 `Proxy.newProxyInstance()`
3. CGLIB：使用 `Enhancer`（需要引入 CGLIB 依赖）

#### Step 4：思考题

1. JDK 动态代理和 CGLIB 有什么区别？
2. Spring AOP 如何选择使用 JDK 动态代理还是 CGLIB？
3. 代理模式和装饰器模式有什么区别？
4. 什么时候用代理模式？什么时候用装饰器模式？

### 验收标准

- [ ] 能运行 ProxyDemo
- [ ] 能手写静态代理
- [ ] 能手写 JDK 动态代理
- [ ] 能手写 CGLIB（选做）
- [ ] 能说清楚 JDK 动态代理和 CGLIB 的区别
- [ ] 理解代理模式的适用场景

---

## 综合练习（选做）

### 练习1：设计模式识别

以下代码分别使用了什么设计模式？

```java
// 代码A
InputStream is = new FileInputStream("file.txt");
is = new BufferedInputStream(is);
is = new DataInputStream(is);
```

```java
// 代码B
Connection conn = DriverManager.getConnection("jdbc:mysql://...");
```

```java
// 代码C
JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
jdbcTemplate.query("SELECT * FROM users", rowMapper);
```

```java
// 代码D
String s1 = "hello";
String s2 = "hello";
System.out.println(s1 == s2); // true
```

```java
// 代码E
UserService proxy = (UserService) Proxy.newProxyInstance(...);
```

### 练习2：模式选择

以下场景应该使用什么结构型模式？

1. 需要使用第三方 SDK，但接口不匹配
2. 图形系统：3 种形状 × 3 种颜色，避免创建 9 个类
3. 文件系统：统一处理文件和文件夹
4. 为输入流动态添加缓冲、加密功能
5. 封装复杂的数据库操作，提供简单接口
6. 大量相似对象（如字符），需要节省内存
7. 为方法调用添加日志、性能监控

### 练习3：Spring 中的设计模式

在你的 Spring 项目中找到以下设计模式的应用：

1. 适配器模式：`HandlerAdapter`
2. 桥接模式：`DataSource` 的不同实现
3. 装饰器模式：Spring AOP 功能增强
4. 外观模式：`JdbcTemplate`
5. 享元模式：线程池、连接池
6. 代理模式：Spring AOP（JDK/CGLIB）

### 练习4：模式对比

请填写以下模式对比表：

| 模式对 | 核心区别 | 一句话总结 |
|--------|---------|-----------|
| 适配器 vs 装饰器 | | |
| 适配器 vs 外观 | | |
| 装饰器 vs 代理 | | |
| 桥接 vs 适配器 | | |
| 组合 vs 装饰器 | | |

---

## 本日实验总结

完成实验后，请填写：

| 实验 | 完成状态 | 最大收获 | 遇到的问题 |
|------|---------|---------|-----------|
| 实验A：适配器模式 | | | |
| 实验B：桥接模式 | | | |
| 实验C：组合模式 | | | |
| 实验D：装饰器模式 | | | |
| 实验E：外观模式 | | | |
| 实验F：享元模式 | | | |
| 实验G：代理模式 | | | |
