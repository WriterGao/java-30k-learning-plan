# Day12 实验与练习

> **实验目标**：通过动手编码验证设计模式结构型模式的核心概念  
> **参考课件**：`00-教学课件_设计模式之结构型模式详解.md`  
> **实验代码**：`code/` 目录

---

## 实验A：实现适配器模式（类适配器 vs 对象适配器）

### 实验目标

1. 理解适配器模式的核心思想（接口转换）
2. 对比类适配器和对象适配器的实现方式
3. 理解为什么推荐使用对象适配器

### 实验步骤

#### Step 1：运行适配器模式演示

```bash
cd Day12/code
javac AdapterDemo.java
java AdapterDemo
```

#### Step 2：观察输出

**观察要点**：
- 类适配器如何通过继承实现接口转换
- 对象适配器如何通过组合实现接口转换
- 两种方式在代码结构上的区别

#### Step 3：自己动手

请实现一个适配器，将第三方支付接口适配到我们系统的支付接口：

```java
// 第三方支付接口（不兼容）
class ThirdPartyPayment {
    public void pay(String orderId, double amount) {
        System.out.println("第三方支付: 订单" + orderId + " 金额" + amount);
    }
}

// 我们系统的支付接口
interface Payment {
    void processPayment(String orderId, double amount);
}
```

要求：
1. 用类适配器方式实现
2. 用对象适配器方式实现
3. 对比两种方式的优缺点

#### Step 4：思考题

1. 如果 Adaptee 是一个 final 类，应该使用哪种适配器？
2. 如果 Adaptee 有多个子类需要适配，应该使用哪种适配器？
3. `InputStreamReader` 是类适配器还是对象适配器？

### 验收标准

- [ ] 能运行 AdapterDemo
- [ ] 能手写对象适配器模式
- [ ] 能说清楚类适配器和对象适配器的区别
- [ ] 理解为什么推荐使用对象适配器

---

## 实验B：实现装饰器模式（增强功能）

### 实验目标

1. 理解装饰器模式如何动态增强功能
2. 对比装饰器模式和继承的区别
3. 理解装饰器模式与代理模式的区别

### 实验步骤

#### Step 1：运行装饰器模式演示

```bash
cd Day12/code
javac DecoratorDemo.java
java DecoratorDemo
```

#### Step 2：观察输出

**观察要点**：
- 装饰器如何在不修改原类的情况下增强功能
- 装饰器可以多层嵌套
- 装饰器模式的灵活性（可以任意组合）

#### Step 3：自己动手

请用装饰器模式实现一个文本处理系统：

```java
// 基础组件
interface Text {
    String getContent();
}

// 具体组件
class PlainText implements Text {
    private String content;
    // ...
}

// 装饰器：加粗
class BoldDecorator implements Text {
    // ...
}

// 装饰器：斜体
class ItalicDecorator implements Text {
    // ...
}

// 装饰器：下划线
class UnderlineDecorator implements Text {
    // ...
}
```

要求：
1. 实现基础文本和三种装饰器
2. 可以任意组合装饰器（如：加粗+斜体+下划线）
3. 验证装饰器可以多层嵌套

#### Step 4：思考题

1. 如果使用继承实现上述功能，需要创建多少个类？
2. 装饰器模式和代理模式在代码结构上有什么区别？
3. Java I/O 流中的 `BufferedInputStream` 装饰了什么？

### 验收标准

- [ ] 能运行 DecoratorDemo
- [ ] 能手写装饰器模式
- [ ] 能说清楚装饰器模式和继承的区别
- [ ] 能说清楚装饰器模式和代理模式的区别

---

## 实验C：实现代理模式（静态代理、JDK动态代理、CGLIB）⭐重点

### 实验目标

1. 理解三种代理模式的实现方式
2. 掌握 JDK 动态代理和 CGLIB 动态代理的使用
3. 理解 Spring AOP 的代理选择机制

### 实验步骤

#### Step 1：运行代理模式演示

```bash
cd Day12/code
javac ProxyDemo.java
java ProxyDemo
```

#### Step 2：观察输出

**观察要点**：
- 静态代理如何控制方法调用
- JDK 动态代理如何通过反射实现
- CGLIB 动态代理如何通过字节码技术实现
- 三种代理方式在性能上的差异

#### Step 3：自己动手

请实现一个用户服务的代理：

```java
// 用户服务接口
interface UserService {
    void saveUser(String name);
    void deleteUser(String name);
}

// 真实服务
class UserServiceImpl implements UserService {
    @Override
    public void saveUser(String name) {
        System.out.println("保存用户: " + name);
    }
    
    @Override
    public void deleteUser(String name) {
        System.out.println("删除用户: " + name);
    }
}
```

要求：
1. 用静态代理实现（添加日志功能）
2. 用 JDK 动态代理实现（添加日志功能）
3. 用 CGLIB 动态代理实现（注意：需要创建一个没有实现接口的类）

#### Step 4：思考题

1. 如果目标对象实现了接口，应该使用哪种代理？为什么？
2. 如果目标对象没有实现接口，应该使用哪种代理？为什么？
3. Spring AOP 默认使用哪种代理？如何强制使用 CGLIB？
4. JDK 动态代理为什么只能代理接口？

### 验收标准

- [ ] 能运行 ProxyDemo
- [ ] 能手写静态代理、JDK 动态代理、CGLIB 动态代理
- [ ] 能说清楚 JDK 动态代理和 CGLIB 动态代理的区别
- [ ] 理解 Spring AOP 的代理选择机制

---

## 实验D：实现外观模式（简化接口）

### 实验目标

1. 理解外观模式如何简化复杂子系统
2. 理解外观模式与适配器模式的区别

### 实验步骤

#### Step 1：运行外观模式演示

```bash
cd Day12/code
javac FacadeDemo.java
java FacadeDemo
```

#### Step 2：观察输出

**观察要点**：
- 外观如何封装多个子系统的调用
- 客户端如何通过外观简化使用
- 外观模式如何降低系统耦合度

#### Step 3：自己动手

请实现一个电商系统的外观：

```java
// 子系统1：库存服务
class InventoryService {
    public boolean checkStock(String productId, int quantity) {
        // 检查库存
        return true;
    }
}

// 子系统2：支付服务
class PaymentService {
    public boolean processPayment(String orderId, double amount) {
        // 处理支付
        return true;
    }
}

// 子系统3：物流服务
class ShippingService {
    public void shipOrder(String orderId, String address) {
        // 发货
    }
}

// 外观：订单服务
class OrderFacade {
    // 一键下单：检查库存 -> 支付 -> 发货
    public void placeOrder(String productId, int quantity, String address, double amount) {
        // ...
    }
}
```

要求：
1. 实现三个子系统服务
2. 实现外观类，封装下单流程
3. 客户端只需要调用外观的一个方法即可完成下单

#### Step 4：思考题

1. 外观模式和适配器模式的区别是什么？
2. 如果子系统发生变化，外观模式需要修改吗？
3. Spring MVC 的 `DispatcherServlet` 是外观模式吗？

### 验收标准

- [ ] 能运行 FacadeDemo
- [ ] 能手写外观模式
- [ ] 能说清楚外观模式和适配器模式的区别
- [ ] 理解外观模式的适用场景

---

## 实验E：实现桥接模式（抽象与实现分离）

### 实验目标

1. 理解桥接模式如何分离抽象和实现
2. 理解桥接模式如何避免类爆炸

### 实验步骤

#### Step 1：运行桥接模式演示

```bash
cd Day12/code
javac BridgeDemo.java
java BridgeDemo
```

#### Step 2：观察输出

**观察要点**：
- 抽象部分和实现部分如何独立变化
- 桥接模式如何避免类爆炸
- 如何通过组合实现灵活扩展

#### Step 3：自己动手

请用桥接模式实现一个消息发送系统：

```java
// 实现类接口：消息发送方式
interface MessageSender {
    void send(String message);
}

// 具体实现：邮件发送
class EmailSender implements MessageSender {
    // ...
}

// 具体实现：短信发送
class SMSSender implements MessageSender {
    // ...
}

// 抽象类：消息
abstract class Message {
    protected MessageSender sender;
    // ...
}

// 扩充抽象：普通消息
class NormalMessage extends Message {
    // ...
}

// 扩充抽象：紧急消息
class UrgentMessage extends Message {
    // ...
}
```

要求：
1. 实现两种消息发送方式（邮件、短信）
2. 实现两种消息类型（普通、紧急）
3. 可以任意组合（如：普通邮件、紧急短信等）
4. 验证不需要创建 2×2=4 个类，只需要 2+2=4 个类

#### Step 4：思考题

1. 如果不使用桥接模式，需要创建多少个类？
2. 桥接模式和适配器模式的区别是什么？
3. JDBC 驱动是桥接模式吗？为什么？

### 验收标准

- [ ] 能运行 BridgeDemo
- [ ] 能手写桥接模式
- [ ] 能说清楚桥接模式如何避免类爆炸
- [ ] 理解桥接模式的适用场景

---

## 综合练习（选做）

### 练习1：设计模式识别

以下代码分别使用了什么设计模式？

```java
// 代码A
Reader reader = new InputStreamReader(new FileInputStream("file.txt"));
```

```java
// 代码B
InputStream input = new BufferedInputStream(new FileInputStream("file.txt"));
```

```java
// 代码C
UserService userService = (UserService) Proxy.newProxyInstance(...);
```

```java
// 代码D
DispatcherServlet servlet = new DispatcherServlet();
```

### 练习2：模式选择

以下场景应该使用什么结构型模式？

1. 需要使用第三方日志库，但其接口不符合我们系统的接口规范
2. 需要在不修改原类的情况下，给方法添加日志、性能监控等功能
3. 需要控制对数据库的访问，添加权限检查、连接池管理等功能
4. 需要简化多个微服务的调用，为客户端提供统一的 API 入口
5. 需要在多个维度上独立扩展（如：不同形状 × 不同颜色）

### 练习3：Spring 中的设计模式

在你的 Spring 项目中找到以下设计模式的应用：

1. 适配器模式：`HandlerAdapter`
2. 装饰器模式：`BufferedInputStream`（Java I/O）
3. 代理模式：`@Transactional`、AOP
4. 外观模式：`DispatcherServlet`

---

## 本日实验总结

完成实验后，请填写：

| 实验 | 完成状态 | 最大收获 | 遇到的问题 |
|------|---------|---------|-----------|
| 实验A：适配器模式 | | | |
| 实验B：装饰器模式 | | | |
| 实验C：代理模式 | | | |
| 实验D：外观模式 | | | |
| 实验E：桥接模式 | | | |
