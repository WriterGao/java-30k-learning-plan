# Day08 实验与练习

> **参考课件**：`00-教学课件_HashMap源码深度分析.md`  
> **实验代码**：`code/` 目录

---

## 0. 环境准备

### 必需工具

- **JDK**：建议使用 JDK 8+
- **IDE 或文本编辑器**：用于查看和修改代码

### 编译代码

```bash
cd Day08/code
javac *.java
```

> **备注**：所有实验代码已提供在 `code/` 目录下，可直接编译运行。

---

## 1. 实验 A：观察 HashMap 扩容过程（必须完成）

### 实验目标

1. 观察 HashMap 扩容的精确触发时机（size > threshold）
2. 理解扩容前后元素的重新分布
3. 验证 JDK 8 的高低位链表拆分优化（e.hash & oldCap）
4. 了解初始容量对扩容次数的影响

### 实验步骤

#### 步骤1：运行扩容观察程序

```bash
java HashMapResizeDemo
```

**观察要点**：
- [ ] 默认容量16，threshold=12，插入第13个元素后首次扩容
- [ ] 每次扩容容量翻倍（16→32→64→128）
- [ ] 高低位链表拆分：hash & oldCap 判断元素去向

**记录**：

| 阶段 | 元素数量 | 容量 | threshold | 是否扩容 |
|------|---------|------|-----------|---------|
| 初始 | 0 | 0 | 0 | — |
| put(1) | 1 | 16 | 12 | 初始化 |
| put(12) | 12 | 16 | 12 | |
| put(13) | 13 | | | |
| put(24) | 24 | | | |
| put(25) | 25 | | | |

#### 步骤2：验证高低位链表拆分

观察实验2的输出，记录：

- 在桶0的元素，扩容后可能在哪些桶？：________
- 在桶5的元素，扩容后可能在哪些桶？：________
- 判断依据（e.hash & oldCap）的含义：________

#### 步骤3：对比初始容量对扩容次数的影响

观察实验4的输出，记录：

| 初始容量 | 插入1000个元素的扩容次数 |
|---------|----------------------|
| 默认(16) | |
| 最优容量 | |
| 过小(4) | |
| 恰好(1024) | |

#### 步骤4：运行 HashMap 基本操作演示

```bash
java HashMapDemo
```

**观察要点**：
- [ ] hash() 扰动函数的效果（高位不同的hashCode扰动后低位也不同）
- [ ] 扩容前后元素位置变化
- [ ] Integer key 在各桶中的分布是否均匀

### 思考题

1. **频繁扩容对性能有什么影响？如何避免？**
   - 

2. **`new HashMap<>(1000)` 实际容量是多少？要存1000个元素会扩容吗？**
   - 

3. **已知要存 n 个元素，推荐的初始容量公式是什么？**
   - 

### 验收标准

- [ ] 能描述扩容的完整过程（新容量、新阈值、数据迁移）
- [ ] 能解释 JDK 8 高低位链表拆分的原理（e.hash & oldCap）
- [ ] 知道如何根据预期数据量设置初始容量，避免不必要的扩容

---

## 2. 实验 B：验证红黑树转换（必须完成）

### 实验目标

1. 观察链表转红黑树的条件（链表≥8 且 table≥64）
2. 理解 treeifyBin 在 table < 64 时改为扩容的行为
3. 验证人为制造的 hash 冲突

### 实验步骤

#### 步骤1：观察 hash 冲突演示

运行 `HashMapDemo` 中的 hash 冲突部分：

```bash
java HashMapDemo
```

观察"hash 冲突演示"部分的输出。

**观察要点**：
- [ ] 自定义 hashCode（全部返回1）时所有 key 在同一个桶
- [ ] 插入 ≥8 个相同 hash 的 key 后，可能触发树化
- [ ] Integer key 在16个桶中的分布

**记录**：
- 12个相同hash的key插入后，是在同一个桶中吗？：________
- 链表长度是否达到了树化条件？：________

#### 步骤2：通过反射验证树化（进阶）

在 IDE 中使用 debug 模式观察：

```java
HashMap<CollidingKey, String> map = new HashMap<>(64); // 容量≥64
for (int i = 0; i < 10; i++) {
    map.put(new CollidingKey(i), "value" + i);
}
// debug：查看 table[?] 的节点类型是 Node 还是 TreeNode
```

**记录**：
- 插入第几个元素时，节点类型从 Node 变为 TreeNode？：________
- 如果初始容量设为8（< 64），插入多个相同hash的key会怎样？：________

### 思考题

1. **为什么树化需要同时满足链表≥8和table≥64两个条件？**
   - 

2. **为什么树化阈值是8而不是其他数字？**
   - 

3. **红黑树退化为链表的条件是什么？为什么退化阈值是6而不是8？**
   - 

### 验收标准

- [ ] 能说出树化的两个条件
- [ ] 理解 table < 64 时为什么扩容而不是树化
- [ ] 能解释泊松分布下链表长度到达8的概率

---

## 3. 实验 C：手写简化版 HashMap（必须完成）

### 实验目标

1. 通过手写加深对 HashMap 核心原理的理解
2. 实现基本的 put/get/remove 操作
3. 实现 JDK 8 高低位链表拆分的扩容机制

### 实验步骤

#### 步骤1：阅读 SimpleHashMap.java 源码

在运行之前，先**仔细阅读**代码中的注释，理解：

- [ ] Node 内部类的结构（hash, key, value, next）
- [ ] hash() 方法的实现（高16位异或低16位）
- [ ] put() 的处理流程（定位桶 → 遍历链表 → 插入/更新）
- [ ] get() 的处理流程
- [ ] resize() 的扩容逻辑（高低位链表拆分）

#### 步骤2：运行测试

```bash
java SimpleHashMap
```

**观察要点**：
- [ ] 基本 put/get 操作正确
- [ ] key 覆盖逻辑正确（返回旧值）
- [ ] 扩容后数据完整
- [ ] remove 操作正确
- [ ] null key 处理正确
- [ ] hash 冲突处理正确（"Aa" 和 "BB" hashCode 相同）
- [ ] 大量数据（10000个元素）的正确性和性能

**记录**：

| 测试 | 期望结果 | 实际结果 | 通过？ |
|------|---------|---------|--------|
| put & get | 正确存取值 | | |
| key 覆盖 | 新值覆盖旧值，返回旧值 | | |
| remove | 正确删除，size 减少 | | |
| null key | 支持 null key | | |
| hash 冲突 | "Aa" 和 "BB" 在同一桶，各自可正确获取 | | |
| 扩容 | 30个元素插入后数据不丢失 | | |
| 大量数据 | 10000个元素全部正确 | | |

#### 步骤3：扩展练习（选做）

尝试为 SimpleHashMap 添加以下功能：

1. **实现 `containsValue()` 方法**

```java
public boolean containsValue(V value) {
    // TODO: 遍历所有桶的所有节点
}
```

2. **实现 `keySet()` 方法**

```java
public Set<K> keySet() {
    // TODO: 返回所有 key 的集合
}
```

3. **实现 `clear()` 方法**

```java
public void clear() {
    // TODO: 清空所有数据
}
```

4. **实现 Iterator 遍历**（挑战级）

```java
public class SimpleHashMap<K, V> implements Iterable<SimpleHashMap.Node<K, V>> {
    // TODO: 实现 Iterator
}
```

### 思考题

1. **你的简化版和 JDK HashMap 最大的差距在哪？**
   - 

2. **如果不实现扩容，HashMap 退化成什么？性能如何？**
   - 

3. **如果不用链地址法处理冲突，还有什么方法？各有什么优缺点？**
   - 

### 验收标准

- [ ] SimpleHashMap 能正确实现 put/get/remove
- [ ] 能正确处理 hash 冲突（链表尾插法）
- [ ] 扩容后数据完整、不丢失
- [ ] 扩容使用了高低位链表拆分（与 JDK 8 一致）
- [ ] 理解简化版与 JDK 版本的差距

---

## 4. 实验 D：HashMap 线程不安全复现（必须完成）

### 实验目标

1. 复现 HashMap 多线程下的数据丢失
2. 观察并发操作导致 size 不准确
3. 复现 ConcurrentModificationException
4. 对比线程安全的 Map 方案的正确性和性能

### 实验步骤

#### 步骤1：运行线程不安全演示

```bash
java HashMapThreadUnsafeDemo
```

**观察要点**：

##### 实验1：并发 put 数据丢失
- [ ] 多线程同时 put 导致数据丢失
- [ ] 每轮运行的丢失数量不同（非确定性bug）

**记录**：

| 轮次 | 期望 size | 实际 size | 丢失数据 |
|------|----------|----------|---------|
| 第1轮 | 100000 | | |
| 第2轮 | 100000 | | |
| 第3轮 | 100000 | | |

##### 实验2：并发 put + get 数据不一致
- [ ] 一边写一边读，可能读到 null（key 明明存在）
- [ ] 扩容期间数据迁移导致的临时不可见

##### 实验3：ConcurrentModificationException
- [ ] for-each 中修改 HashMap 触发 CME
- [ ] 正确做法：使用 Iterator.remove() 或 removeIf()

##### 实验4：size 不准确
- [ ] size++ 非原子操作，多线程导致 size < 实际元素数

##### 实验5：线程安全方案对比
- [ ] HashMap：数据丢失，性能最快
- [ ] Hashtable：数据正确，性能最慢
- [ ] synchronizedMap：数据正确，性能慢
- [ ] ConcurrentHashMap：数据正确，性能较好

**记录**：

| 方案 | 期望 size | 实际 size | 正确? | 耗时(ms) |
|------|----------|----------|-------|---------|
| HashMap | 500000 | | | |
| Hashtable | 500000 | | | |
| synchronizedMap | 500000 | | | |
| ConcurrentHashMap | 500000 | | | |

#### 步骤2：多次运行观察

多次运行实验1，观察 HashMap 数据丢失的变化：

| 次数 | HashMap 实际 size | 丢失百分比 |
|------|------------------|-----------|
| 第1次 | | |
| 第2次 | | |
| 第3次 | | |
| 第4次 | | |
| 第5次 | | |

#### 步骤3：理解 JDK 7 死循环原理

阅读实验6的输出，理解死循环的形成过程。

**记录**：
- 头插法如何导致链表反转？：________
- 两个线程如何形成环形链表？：________
- JDK 8 为什么不会死循环？：________

### 思考题

1. **在实际项目中，你会如何选择线程安全的 Map？**
   - 

2. **ConcurrentHashMap 为什么比 Hashtable 性能好？**
   - 

3. **什么场景下可以安全地使用 HashMap？**
   - 

4. **JDK 8 的 HashMap 虽然不会死循环了，但还是不安全的，为什么？**
   - 

### 验收标准

- [ ] 能复现 HashMap 多线程数据丢失
- [ ] 能复现 ConcurrentModificationException
- [ ] 理解数据丢失的根本原因（竞态条件）
- [ ] 理解 JDK 7 死循环的形成原理
- [ ] 知道 3 种线程安全 Map 的优缺点和选择策略
- [ ] 能回答面试中 HashMap 线程安全相关问题

---

## 5. 综合验收

完成所有实验后，回答以下综合问题：

### 5.1 知识串联

1. **从 `put("key", "value")` 开始，完整描述数据存储的全过程**
   - 

2. **从 `get("key")` 开始，完整描述数据查找的全过程**
   - 

3. **HashMap 的性能瓶颈在哪？如何优化？**
   - 

4. **你觉得 HashMap 源码中，最巧妙的设计是什么？为什么？**
   - 

### 5.2 实验总结

| 实验 | 完成情况 | 关键收获 |
|------|---------|---------|
| A: 扩容过程观察 | [ ] 完成 | |
| B: 红黑树转换验证 | [ ] 完成 | |
| C: 手写简化版 HashMap | [ ] 完成 | |
| D: 线程不安全复现 | [ ] 完成 | |

### 5.3 面试模拟

请用 5 分钟时间，模拟回答以下面试题：

> **面试官**：请你讲一下 HashMap 的底层原理，包括 put 方法的流程和扩容机制。

你的回答：

```
（在此写下你的回答）
```

> **面试官追问**：HashMap 是线程安全的吗？JDK 7 的死循环问题是怎么回事？

你的回答：

```
（在此写下你的回答）
```

---

> **提示**：完成所有实验后，请在 `02-学习笔记.md` 中记录你的实验结果和思考。
