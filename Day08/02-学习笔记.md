# Day08 学习笔记

> **学习目标**：今天的笔记目标是"**能复述、能画图、能用代码验证**"，不要抄书。  
> **参考课件**：`00-教学课件_HashMap源码深度分析.md`

---

## 1. HashMap 数据结构（用你自己的话）

### 1.1 底层结构是什么？

请用一句话概括 HashMap 的底层数据结构：

- 

### 1.2 为什么要用"数组 + 链表 + 红黑树"？

- 数组的作用：
- 链表的作用：
- 红黑树的作用：
- 三者如何协作：

### 1.3 请画出 HashMap 的内存结构图

```
（在此画图，包含数组、链表节点、红黑树节点）
```

---

## 2. 核心常量与字段

### 2.1 关键常量

请填写以下常量的值和作用：

| 常量 | 值 | 作用 |
|------|---|------|
| DEFAULT_INITIAL_CAPACITY | | |
| MAXIMUM_CAPACITY | | |
| DEFAULT_LOAD_FACTOR | | |
| TREEIFY_THRESHOLD | | |
| UNTREEIFY_THRESHOLD | | |
| MIN_TREEIFY_CAPACITY | | |

### 2.2 核心字段

- **table**：
- **size**：
- **modCount**：
- **threshold**：
- **loadFactor**：

### 2.3 为什么容量必须是 2 的幂？

- 

---

## 3. hash() 方法

### 3.1 hash() 方法的代码

请默写 hash() 方法：

```java
// 你的默写
```

### 3.2 扰动函数的设计

- **为什么要高16位异或低16位**：
- **这样做的好处**：
- **如果不做扰动会怎样**：

### 3.3 为什么用 (n-1) & hash 而不是 hash % n？

- 

---

## 4. put() 方法源码分析

### 4.1 put() 完整流程

请用自己的话描述 put() 的完整流程（参考课件第5章）：

1. 
2. 
3. 
4. 
5. 
6. 
7. 

### 4.2 画出 put() 流程图

```
（在此画出 putVal 的完整流程图）
```

### 4.3 关键判断点

- **table 为空时怎么处理**：
- **hash 冲突时怎么处理**：
- **链表长度 >= 8 时怎么处理**：
- **key 已存在时怎么处理**：
- **插入后 size > threshold 怎么处理**：

---

## 5. get() 方法源码分析

### 5.1 get() 完整流程

请用自己的话描述 get() 的完整流程：

1. 
2. 
3. 
4. 

### 5.2 为什么先检查第一个节点？

- 

---

## 6. resize() 扩容机制

### 6.1 什么时候触发扩容？

- 条件1：
- 条件2：
- 条件3：

### 6.2 扩容的过程

请描述 resize() 的核心步骤：

1. 
2. 
3. 
4. 

### 6.3 JDK 8 的高低位链表优化

- **什么是高低位链表**：
- **判断依据是什么（e.hash & oldCap）**：
- **为什么这样做比 JDK 7 好**：

### 6.4 图解扩容过程

```
（在此画出扩容前后的数据迁移图）
```

---

## 7. 链表转红黑树

### 7.1 转换条件

- **链表长度阈值**：
- **数组长度阈值**：
- **为什么有两个条件**：

### 7.2 为什么阈值是 8？

- **泊松分布的解释**：
- **链表长度达到8的概率**：

### 7.3 treeifyBin 的过程

1. 
2. 
3. 

### 7.4 什么时候红黑树退化为链表？

- 条件：
- 阈值：

---

## 8. 红黑树基础

### 8.1 红黑树的五条性质

1. 
2. 
3. 
4. 
5. 

### 8.2 左旋和右旋

请用文字描述左旋操作：

```
（在此画图）
```

请用文字描述右旋操作：

```
（在此画图）
```

### 8.3 插入后的调整

- **Case 1（叔叔是红色）**：
- **Case 2（叔叔是黑色，当前节点是右子）**：
- **Case 3（叔叔是黑色，当前节点是左子）**：

---

## 9. remove() 方法源码分析

### 9.1 remove() 的流程

1. 
2. 
3. 
4. 

### 9.2 删除链表中间节点的操作

```
（画出 p.next = node.next 的过程）
```

---

## 10. JDK 7 vs JDK 8 对比

### 10.1 核心差异

| 特性 | JDK 7 | JDK 8 |
|------|-------|-------|
| 底层结构 | | |
| 插入方式 | | |
| hash 方法 | | |
| 扩容机制 | | |
| 链表长度过长 | | |
| 并发安全 | | |

### 10.2 头插法 vs 尾插法

- **JDK 7 头插法的问题**：
- **JDK 8 尾插法的好处**：

---

## 11. JDK 7 多线程死循环问题

### 11.1 死循环是怎么产生的？

请用自己的话描述（参考课件第7章和第10章）：

1. 
2. 
3. 
4. 

### 11.2 画出环形链表

```
（在此画出环形链表的形成过程）
```

### 11.3 JDK 8 是否彻底解决了？

- 

---

## 12. HashMap 线程不安全场景

### 12.1 有哪些线程不安全的表现？

1. 
2. 
3. 
4. 

### 12.2 解决方案

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|---------|
| Collections.synchronizedMap | | | |
| Hashtable | | | |
| ConcurrentHashMap | | | |

---

## 13. HashMap 与其他 Map 对比

### 13.1 HashMap vs Hashtable（至少3个区别）

1. 
2. 
3. 

### 13.2 HashMap vs ConcurrentHashMap（至少3个区别）

1. 
2. 
3. 

### 13.3 HashMap vs LinkedHashMap

- 

### 13.4 HashMap vs TreeMap

- 

---

## 14. 手写简化版 HashMap

### 14.1 核心思路

- **存储结构**：
- **hash 计算**：
- **put 逻辑**：
- **get 逻辑**：
- **扩容逻辑**：

### 14.2 与 JDK HashMap 的差距

1. 
2. 
3. 

---

## 15. 5 分钟复述稿（面试式）

用 5 分钟讲清楚"HashMap 源码"，要求：
- 先总览，再逐一解释，再给关键实现细节

**我的复述稿**：

```
【数据结构】
HashMap 底层是数组 + 链表 + 红黑树...
数组是 Node<K,V>[] table...

【核心方法】
put() 的流程：计算 hash → 定位桶 → 处理冲突...
get() 的流程：...

【扩容机制】
resize() 在 size > threshold 时触发...
JDK 8 优化：高低位链表拆分...

【红黑树】
链表长度 >= 8 且数组长度 >= 64 时转为红黑树...

【线程安全】
HashMap 是线程不安全的...
JDK 7 头插法多线程会产生死循环...
```

---

## 16. 学习总结与疑问

### 16.1 今天学到的核心知识点

1. 
2. 
3. 
4. 
5. 

### 16.2 还有疑问的地方

1. 
2. 

### 16.3 下一步学习计划

- [ ] 复习课件的面试高频问题
- [ ] 阅读 HashMap 源码原文（java.util.HashMap）
- [ ] 了解 ConcurrentHashMap 源码
- [ ] 准备下一天的学习

---

> **提示**：完成笔记后，对照课件中的面试问题进行自我验收。
