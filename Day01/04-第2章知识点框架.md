# 第2章：Java内存区域与内存溢出异常 - 知识点框架

> 本文件基于《深入理解Java虚拟机（第3版）》第2章的知识点结构，提供学习框架与要点总结（不含书籍原文）。  
> 请结合 `01-阅读导学_第2章.md` 与 `02-学习笔记.md` 使用。

---

## 📚 第2章核心知识点结构

### 2.1 概述
- **学习目标**：理解为什么需要了解JVM内存区域
- **关键点**：内存管理是JVM的核心功能之一

### 2.2 运行时数据区域

#### 2.2.1 程序计数器（Program Counter Register）
- **作用**：记录当前线程执行的字节码指令地址
- **特点**：
  - 线程私有
  - 唯一不会发生OutOfMemoryError的区域
  - 执行Native方法时，值为空（Undefined）
- **面试要点**：为什么需要程序计数器？多线程切换时如何保证正确执行？

#### 2.2.2 Java虚拟机栈（Java Virtual Machine Stack）
- **作用**：存储局部变量表、操作数栈、动态链接、方法出口等信息
- **栈帧（Stack Frame）**：
  - 每个方法对应一个栈帧
  - 方法调用时创建，方法结束时销毁
- **异常**：
  - **StackOverflowError**：栈深度超过虚拟机允许的最大深度
  - **OutOfMemoryError**：无法申请到足够内存扩展栈
- **实验代码**：参考 `code/StackOverflowDemo.java`

#### 2.2.3 本地方法栈（Native Method Stack）
- **作用**：为Native方法服务
- **特点**：与Java虚拟机栈类似，但服务于Native方法
- **注意**：HotSpot虚拟机将本地方法栈与Java虚拟机栈合二为一

#### 2.2.4 Java堆（Java Heap）
- **作用**：存放对象实例和数组（GC的主要区域）
- **分区**：
  - **新生代（Young Generation）**：
    - Eden区
    - Survivor区（From Survivor、To Survivor）
  - **老年代（Old Generation）**
- **特点**：
  - 线程共享
  - 可物理上不连续，但逻辑上连续
  - 可扩展（通过-Xmx和-Xms控制）
- **异常**：OutOfMemoryError（堆内存溢出）
- **实验代码**：参考 `code/HeapOomDemo.java` 和 `code/HeapAllocationDemo.java`

#### 2.2.5 方法区（Method Area）
- **作用**：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等
- **JDK版本差异**：
  - **JDK 7及以前**：永久代（PermGen），属于堆的一部分
  - **JDK 8及以后**：元空间（Metaspace），使用本地内存
- **异常**：OutOfMemoryError（方法区溢出，如类加载过多）

#### 2.2.6 运行时常量池（Runtime Constant Pool）
- **作用**：存放编译期生成的各种字面量和符号引用
- **特点**：属于方法区的一部分
- **动态性**：运行期间可以将新的常量放入池中（如String.intern()）

#### 2.2.7 直接内存（Direct Memory）
- **作用**：NIO使用Native函数库直接分配堆外内存
- **特点**：
  - 不受Java堆大小限制
  - 受本机总内存和处理器寻址空间限制
- **异常**：OutOfMemoryError（直接内存溢出）

---

### 2.3 HotSpot虚拟机对象探秘

#### 2.3.1 对象的创建
**对象创建的完整流程**：
1. **检查类是否已加载**：检查new指令的参数是否能在常量池中定位到类的符号引用
2. **分配内存**：
   - **指针碰撞（Bump the Pointer）**：适用于堆内存规整（Serial、ParNew等收集器）
   - **空闲列表（Free List）**：适用于堆内存不规整（CMS等收集器）
3. **内存空间初始化**：将分配的内存空间初始化为零值（不包括对象头）
4. **设置对象头**：设置对象的类元数据信息、哈希码、GC分代年龄等
5. **执行init方法**：执行`<init>()`方法，初始化对象

**内存分配的并发问题**：
- **CAS + 失败重试**：保证原子性
- **TLAB（Thread Local Allocation Buffer）**：为每个线程预先分配一小块内存

#### 2.3.2 对象的内存布局
对象在堆内存中的存储布局：
- **对象头（Header）**：
  - **Mark Word**：存储对象的哈希码、GC分代年龄、锁状态标志等
  - **类型指针**：指向类元数据的指针
  - **数组长度**（仅数组对象）：记录数组长度
- **实例数据（Instance Data）**：对象真正存储的有效信息
- **对齐填充（Padding）**：保证对象大小为8字节的整数倍

#### 2.3.3 对象的访问定位
**两种访问方式**：
1. **句柄访问**：
   - 堆中维护句柄池
   - 句柄包含对象实例数据指针和类型数据指针
   - 优点：对象移动时只需修改句柄，reference不变
   - 缺点：多一次间接访问
2. **直接指针访问**：
   - reference直接指向对象
   - 优点：访问速度快（HotSpot采用此方式）
   - 缺点：对象移动时需要修改reference

---

### 2.4 实战：OutOfMemoryError异常

#### 2.4.1 Java堆溢出
- **触发条件**：不断创建对象，且对象无法被GC回收
- **异常信息**：`java.lang.OutOfMemoryError: Java heap space`
- **解决思路**：
  - 检查是否有内存泄漏（使用内存分析工具）
  - 检查堆内存设置是否合理（-Xmx、-Xms）
  - 检查代码中是否有对象生命周期过长的问题
- **实验代码**：`code/HeapOomDemo.java`

#### 2.4.2 虚拟机栈和本地方法栈溢出
- **StackOverflowError**：
  - 触发条件：栈深度超过虚拟机允许的最大深度
  - 常见场景：递归调用过深、方法调用链过长
- **OutOfMemoryError**：
  - 触发条件：无法申请到足够内存扩展栈
  - 常见场景：创建过多线程
- **实验代码**：`code/StackOverflowDemo.java`

#### 2.4.3 方法区和运行时常量池溢出
- **JDK 7及以前（永久代溢出）**：
  - 触发条件：大量动态生成类（如CGLib动态代理）
  - 异常信息：`java.lang.OutOfMemoryError: PermGen space`
- **JDK 8及以后（元空间溢出）**：
  - 触发条件：类加载过多
  - 异常信息：`java.lang.OutOfMemoryError: Metaspace`
- **JVM参数**：
  - JDK 7：`-XX:MaxPermSize`
  - JDK 8+：`-XX:MaxMetaspaceSize`

#### 2.4.4 本机直接内存溢出
- **触发条件**：直接内存使用超过限制
- **异常信息**：`java.lang.OutOfMemoryError: Direct buffer memory`
- **特点**：Heap Dump文件不会显示明显异常，但程序会崩溃

---

## 🎯 学习检查清单

完成第2章学习后，请确认你能回答以下问题：

### 基础理解
- [ ] 能画出JVM运行时数据区的完整结构图
- [ ] 能说出每个区域的作用、线程私有/共享属性、生命周期
- [ ] 能解释对象创建的完整流程（从new到可用）

### 深入理解
- [ ] 能解释为什么程序计数器不会发生OOM
- [ ] 能区分StackOverflowError和OutOfMemoryError的触发场景
- [ ] 能解释堆内存分代的原因和GC的关系
- [ ] 能说出方法区在不同JDK版本中的实现差异

### 实战能力
- [ ] 能通过代码复现堆内存溢出
- [ ] 能通过代码复现栈溢出
- [ ] 能使用jvisualvm等工具观察内存使用情况
- [ ] 能分析GC日志，找出内存问题

---

## 📝 学习建议

1. **先理解整体结构**：画出运行时数据区的结构图，标注每个区域的作用
2. **再深入细节**：重点理解堆、栈、方法区的实现细节
3. **最后实践验证**：运行实验代码，观察内存变化，分析异常原因
4. **总结输出**：在 `02-学习笔记.md` 中记录你的理解和思考

---

## 🔗 相关资源

- **实验代码**：`code/` 目录下的所有Java文件
- **学习笔记模板**：`02-学习笔记.md`
- **实验指导**：`03-实验与练习.md`
- **阅读导学**：`01-阅读导学_第2章.md`

---

> **提示**：本框架基于公开的JVM知识整理，不包含书籍原文。请结合《深入理解Java虚拟机（第3版）》第2章原文进行学习。
