# Day01 实验与练习

> **参考课件**：`00-教学课件_JVM内存模型详解.md` 第10章  
> **实验代码**：`code/` 目录

---

## 0. 环境准备

### 必需工具

- **JDK**：建议使用你正在学习/工作使用的版本（例如 17/21），保持一致
- **可视化工具**：
  - 如果你的环境有 `jvisualvm`：直接使用
  - 如果没有：安装 VisualVM（独立工具）或改用命令行工具（`jcmd/jstat`）

### 工具检查

```bash
# 检查JDK版本
java -version

# 检查jvisualvm是否可用
jvisualvm --version

# 如果没有jvisualvm，可以使用jstat观察GC
jstat -gc <pid> 1000  # 每秒打印一次GC信息
```

> **备注**：不同 JDK 的工具分布不同，这是正常的；今天的目标是"能观察到堆变化与 GC"，工具可替换。

---

## 1. 实验 A：堆分配与增长（必须完成）

### 实验目标

观察对象不断分配时，堆使用量如何增长；在有限 `-Xmx` 下触发明显的 GC 行为。

### 实验代码

**文件**：`code/HeapAllocationDemo.java`

**参考课件**：第10.4节

### 实验步骤

1. **编译代码**：
   ```bash
   javac code/HeapAllocationDemo.java
   ```

2. **运行代码**（设置较小的堆内存，便于观察）：
   ```bash
   java -Xms100m -Xmx100m \
        -XX:+PrintGCDetails \
        -XX:+PrintGCDateStamps \
        -Xloggc:gc.log \
        -cp . code.HeapAllocationDemo
   ```

3. **同时启动jvisualvm观察**：
   ```bash
   jvisualvm
   ```
   - 在jvisualvm中选择你的Java进程
   - 观察"监视"标签中的堆内存曲线
   - 如果安装了Visual GC插件，可以观察更详细的GC活动

### 记录项（写在 `02-学习笔记.md`）

- **JVM 参数**（`-Xms/-Xmx`）：
- **你看到的堆曲线变化**：
  - 初始堆使用：
  - 峰值堆使用：
  - GC发生时的现象：
- **你在 GC 发生时的现象**（暂停、吞吐变化等）：
  - Minor GC频率：
  - Full GC是否发生：
  - GC暂停时间：

### 预期现象

- 堆内存使用率逐渐上升
- 当Eden区满时，触发Minor GC
- GC后堆内存使用率下降
- 如果老年代也满了，可能触发Full GC

---

## 2. 实验 B：制造堆 OOM（建议完成）

### 实验目标

可控地触发 `java.lang.OutOfMemoryError: Java heap space`

### 实验代码

**文件**：`code/HeapOomDemo.java`

**参考课件**：第10.1节

### 实验步骤

1. **编译代码**：
   ```bash
   javac code/HeapOomDemo.java
   ```

2. **运行代码**（设置很小的堆内存，快速触发OOM）：
   ```bash
   java -Xms20m -Xmx20m \
        -XX:+HeapDumpOnOutOfMemoryError \
        -XX:HeapDumpPath=./heap.hprof \
        -cp . code.HeapOomDemo
   ```

3. **观察异常信息**：
   - 异常类型：`java.lang.OutOfMemoryError: Java heap space`
   - 堆转储文件：`heap.hprof`（如果设置了HeapDumpOnOutOfMemoryError）

4. **分析堆转储**（可选）：
   - 使用jvisualvm打开 `heap.hprof`
   - 查看哪些对象占用内存最多

### 验收标准

- [ ] 能稳定复现 OOM
- [ ] 能解释"为什么会 OOM"（数据结构持有引用/增长速度/堆上限）
- [ ] 能给出至少 2 种缓解方案（参数 + 代码/设计）

### 缓解方案示例

**方案1：增加堆内存**
```bash
java -Xms512m -Xmx512m ...
```

**方案2：优化代码**
- 检查是否有内存泄漏
- 及时释放不需要的对象引用
- 使用对象池减少对象创建

---

## 3. 实验 C：栈溢出（可选但推荐）

### 实验目标

触发 `StackOverflowError`，理解"递归深度/栈帧大小"的影响

### 实验代码

**文件**：`code/StackOverflowDemo.java`

**参考课件**：第10.2节

### 实验步骤

1. **编译代码**：
   ```bash
   javac code/StackOverflowDemo.java
   ```

2. **运行代码**（减小栈大小，更快触发溢出）：
   ```bash
   java -Xss128k -cp . code.StackOverflowDemo
   ```

3. **观察异常信息**：
   - 异常类型：`java.lang.StackOverflowError`
   - 栈深度：记录程序输出的栈深度

4. **调整栈大小，观察变化**：
   ```bash
   java -Xss256k -cp . code.StackOverflowDemo  # 栈深度会增加
   java -Xss512k -cp . code.StackOverflowDemo  # 栈深度会进一步增加
   ```

### 记录项

- **不同栈大小下的栈深度**：
  - `-Xss128k`：
  - `-Xss256k`：
  - `-Xss512k`：

### 理解要点

- 栈大小越大，能支持的递归深度越深
- 但栈大小不能无限增大（受系统限制）
- 递归算法需要考虑栈深度限制

---

## 4. 实验 D：使用jvisualvm观察内存（推荐）

### 实验目标

熟练使用jvisualvm工具观察内存使用情况

### 实验步骤

1. **启动你的Java程序**（任意一个实验代码）：
   ```bash
   java -Xms512m -Xmx512m -cp . code.HeapAllocationDemo
   ```

2. **启动jvisualvm**：
   ```bash
   jvisualvm
   ```

3. **连接到Java进程**：
   - 左侧选择你的Java进程
   - 点击"监视"标签

4. **观察内存使用**：
   - 堆内存使用曲线
   - 非堆内存使用曲线
   - 线程数
   - 类加载数

5. **查看GC活动**（如果安装了Visual GC插件）：
   - Eden区、Survivor区、老年代的使用情况
   - GC频率和耗时

6. **生成堆转储**（可选）：
   - 右键进程 → "堆转储"
   - 分析哪些对象占用内存最多

### 参考课件

详见课件第10.3节

---

## 5. 今日验收（完成即达标）

### 基础验收

- [ ] 能画出 JVM 运行时数据区并解释每个区域
- [ ] 至少完成 1 个实验并写清楚"参数/现象/结论"（记录在 `02-学习笔记.md`）
- [ ] 写出一段 5 分钟复述稿（见 `02-学习笔记.md`）

### 进阶验收

- [ ] 完成所有3个实验（堆分配、堆OOM、栈溢出）
- [ ] 能使用jvisualvm观察内存使用情况
- [ ] 能分析GC日志，找出内存问题
- [ ] 能回答课件第11.3节的面试高频问题

### 验收标准

参考课件第11.2节的检查清单进行自我验收。

---

## 6. 常见问题

### Q1: jvisualvm找不到？

**A**: 
- macOS: 通常在 `/Library/Java/JavaVirtualMachines/<JDK>/Contents/Home/bin/jvisualvm`
- 或者下载独立的VisualVM：https://visualvm.github.io/

### Q2: GC日志看不懂？

**A**: 参考课件第10.4节的GC日志分析部分，或者使用在线GC日志分析工具。

### Q3: 实验代码运行报错？

**A**: 
- 检查JDK版本是否兼容
- 检查类路径是否正确（`-cp .`）
- 检查包名是否正确（如果代码中有package声明）

---

> **提示**：完成实验后，务必在 `02-学习笔记.md` 中记录你的观察结果和思考。
