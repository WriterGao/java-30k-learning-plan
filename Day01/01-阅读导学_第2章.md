# 阅读导学：《深入理解 Java 虚拟机》第 2 章（不含原文）

> 本文件不包含书籍原文，仅用于指导你按“第 2 章”完成阅读与自写笔记。  
> 章节小节名称以 `00-版本确认.md` 里你填写的目录为准。

## 阅读目标（今天必须达成）

- 能**画出 JVM 运行时数据区**并解释每个区域的职责、生命周期、线程私有/共享属性
- 能解释“对象从创建到可被回收”的关键路径（从**分配**到**可达性**的直觉）
- 能说清楚：哪些问题通常会导致 **OOM/StackOverflow**，以及如何“复现 + 定位 + 缓解”

## 建议阅读顺序（按理解链路）

1. **先看总览/术语**：运行时数据区有哪些，线程私有 vs 共享
2. **再看堆相关细节**：分代（新生代/老年代）与元空间/方法区概念边界
3. **最后看异常与案例**：各类内存溢出/栈溢出的触发方式与诊断手段

> 你的书若第 2 章的小节顺序不同，以书为准，但请沿用上面的“理解链路”去整理笔记。

## 阅读时的“检查点”清单（读完要能回答）

### 运行时数据区

- **程序计数器**：为什么需要？它会不会 OOM？  
- **Java 虚拟机栈**：栈帧里大致有什么？什么情况下会 StackOverflow？  
- **本地方法栈**：与 JVM 栈的关系？你使用时如何感知它的存在？  
- **堆**：为什么是 GC 的主战场？对象通常如何在堆里分配？  
- **方法区/元空间**：它主要存什么？“类加载多”会带来什么问题？（提示：类元数据/常量池/类卸载）

### 对象创建与引用

- 对象创建的关键步骤有哪些？（从“new”到对象可用）
- 什么是“引用类型”的差异（强/软/弱/虚）？你日常开发中各自最典型的用途是什么？

### 常见故障类型（能举例 + 能复现）

- **Java 堆 OOM**：最常见的触发方式是什么？如何通过限制 `-Xmx` 更快复现？
- **栈溢出**：递归 vs 栈帧过大分别如何触发？
- **元空间/方法区相关问题**：什么情况下类会“越加载越多”？如何验证？

## 读书输出（强制要求）

请把你的最终输出写进 `02-学习笔记.md`，至少包含：

- 1 张“运行时数据区”结构图（可以用文字/ASCII 画）
- 3 个“你自己的例子”（比如：线程私有/共享的实际影响、一个 OOM 复现、一个栈溢出复现）
- 1 页“面试式复述”（假装你在 5 分钟内讲给别人听）

