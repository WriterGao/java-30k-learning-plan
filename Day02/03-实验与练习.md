# Day02 实验与练习

> **参考课件**：`00-教学课件_GC算法与垃圾收集器详解.md`  
> **实验代码**：`code/` 目录

---

## 0. 环境准备

### 必需工具

- **JDK**：建议使用 JDK 8+ 或你正在使用的版本（如 17/21）
- **命令行工具**：`java`、`javac`、`jstat`、`jinfo`
- **可视化工具**（可选）：jvisualvm、VisualVM、GCViewer

### 环境检查

```bash
# 检查JDK版本
java -version

# 检查可用的GC收集器
java -XX:+PrintFlagsFinal -version 2>&1 | grep -i "Use.*GC"

# 检查默认GC收集器
java -XX:+PrintCommandLineFlags -version
```

### GC 日志参数说明

不同 JDK 版本的 GC 日志参数不同：

**JDK 8 及以前**：
```bash
-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:gc.log
```

**JDK 9+（统一日志框架）**：
```bash
-Xlog:gc*:file=gc.log:time,uptime,level,tags
```

> **备注**：本实验代码中同时提供两种参数写法，请根据你的 JDK 版本选择。

---

## 1. 实验 A：配置不同 GC 收集器，观察 GC 日志（必须完成）

### 实验目标

分别使用不同的 GC 收集器运行同一个程序，对比 GC 日志的差异。

### 实验代码

**文件**：`code/GCLogDemo.java`

### 实验步骤

1. **编译代码**：
   ```bash
   cd Day02/code
   javac GCLogDemo.java
   ```

2. **使用 Serial 收集器运行**：
   ```bash
   # JDK 8
   java -Xms64m -Xmx64m -Xmn32m \
        -XX:+UseSerialGC \
        -XX:+PrintGCDetails -XX:+PrintGCDateStamps \
        -Xloggc:gc_serial.log \
        GCLogDemo

   # JDK 9+
   java -Xms64m -Xmx64m -Xmn32m \
        -XX:+UseSerialGC \
        -Xlog:gc*:file=gc_serial.log:time,uptime,level,tags \
        GCLogDemo
   ```

3. **使用 Parallel 收集器运行**：
   ```bash
   # JDK 8
   java -Xms64m -Xmx64m -Xmn32m \
        -XX:+UseParallelGC \
        -XX:+PrintGCDetails -XX:+PrintGCDateStamps \
        -Xloggc:gc_parallel.log \
        GCLogDemo

   # JDK 9+
   java -Xms64m -Xmx64m -Xmn32m \
        -XX:+UseParallelGC \
        -Xlog:gc*:file=gc_parallel.log:time,uptime,level,tags \
        GCLogDemo
   ```

4. **使用 G1 收集器运行**：
   ```bash
   # JDK 8
   java -Xms64m -Xmx64m \
        -XX:+UseG1GC \
        -XX:+PrintGCDetails -XX:+PrintGCDateStamps \
        -Xloggc:gc_g1.log \
        GCLogDemo

   # JDK 9+
   java -Xms64m -Xmx64m \
        -XX:+UseG1GC \
        -Xlog:gc*:file=gc_g1.log:time,uptime,level,tags \
        GCLogDemo
   ```

5. **对比 GC 日志**：
   - 打开三个日志文件，对比以下指标：
     - GC 次数
     - GC 暂停时间
     - 日志格式差异（收集器名称等）

### 记录项（写在 `02-学习笔记.md`）

| 收集器 | Minor GC 次数 | Full GC 次数 | 平均暂停时间 | 总暂停时间 |
|-------|--------------|-------------|-------------|-----------|
| Serial | | | | |
| Parallel | | | | |
| G1 | | | | |

### 预期现象

- Serial 收集器的日志中出现 `DefNew`（新生代）和 `Tenured`（老年代）
- Parallel 收集器的日志中出现 `PSYoungGen` 和 `ParOldGen`
- G1 收集器的日志中出现 `G1 Evacuation Pause` 等特殊格式

---

## 2. 实验 B：模拟 Full GC，分析 GC 日志（建议完成）

### 实验目标

通过不断分配大对象，触发 Full GC，观察 GC 日志中 Full GC 的详细信息。

### 实验代码

**文件**：`code/GCLogDemo.java`（使用 `fullGCDemo()` 方法）

### 实验步骤

1. **编译代码**（如果已编译可跳过）：
   ```bash
   cd Day02/code
   javac GCLogDemo.java
   ```

2. **运行代码**（设置较小堆内存，强制触发 Full GC）：
   ```bash
   # JDK 8
   java -Xms30m -Xmx30m -Xmn10m \
        -XX:+UseSerialGC \
        -XX:+PrintGCDetails -XX:+PrintGCDateStamps \
        -Xloggc:gc_fullgc.log \
        GCLogDemo fullgc

   # JDK 9+
   java -Xms30m -Xmx30m -Xmn10m \
        -XX:+UseSerialGC \
        -Xlog:gc*:file=gc_fullgc.log:time,uptime,level,tags \
        GCLogDemo fullgc
   ```

3. **分析 GC 日志**：
   - 找到 Full GC 的日志行
   - 分析 Full GC 的触发原因
   - 记录 Full GC 前后的堆内存使用情况

### GC 日志解读模板

```
[Full GC (Allocation Failure) [Tenured: 19456K->19456K(20480K), 0.0234567 secs]
 29696K->29696K(30208K), [Metaspace: 2655K->2655K(1056768K)], 0.0235678 secs]
```

- `Full GC`：GC 类型
- `Allocation Failure`：触发原因
- `Tenured: 19456K->19456K(20480K)`：老年代 GC 前 -> GC 后（总大小）
- `0.0234567 secs`：老年代 GC 耗时
- `29696K->29696K(30208K)`：整个堆 GC 前 -> GC 后（总大小）
- `Metaspace`：元空间信息

### 记录项

- **Full GC 触发次数**：
- **Full GC 触发原因**：
- **Full GC 前堆使用**：
- **Full GC 后堆使用**：
- **Full GC 暂停时间**：

### 验收标准

- [ ] 能成功触发 Full GC
- [ ] 能在日志中识别出 Full GC 行
- [ ] 能解读 Full GC 日志的每个字段
- [ ] 能说出 Full GC 的触发原因

---

## 3. 实验 C：对比不同收集器的性能表现（建议完成）

### 实验目标

使用同一个高负载程序，对比不同收集器的吞吐量和暂停时间。

### 实验代码

**文件**：`code/GCLogDemo.java`（使用 `performanceTest()` 方法）

### 实验步骤

1. **使用 Serial 收集器**：
   ```bash
   java -Xms128m -Xmx128m -Xmn64m \
        -XX:+UseSerialGC \
        GCLogDemo perf
   ```

2. **使用 Parallel 收集器**：
   ```bash
   java -Xms128m -Xmx128m -Xmn64m \
        -XX:+UseParallelGC \
        GCLogDemo perf
   ```

3. **使用 CMS 收集器**（JDK 8，JDK 14+ 已移除）：
   ```bash
   java -Xms128m -Xmx128m -Xmn64m \
        -XX:+UseConcMarkSweepGC \
        GCLogDemo perf
   ```

4. **使用 G1 收集器**：
   ```bash
   java -Xms128m -Xmx128m \
        -XX:+UseG1GC \
        GCLogDemo perf
   ```

5. **使用 ZGC 收集器**（JDK 11+）：
   ```bash
   java -Xms128m -Xmx128m \
        -XX:+UseZGC \
        GCLogDemo perf
   ```

### 记录项

| 收集器 | 执行时间(ms) | GC总暂停(ms) | 吞吐量 | 备注 |
|-------|------------|-------------|-------|------|
| Serial | | | | |
| Parallel | | | | |
| CMS | | | | |
| G1 | | | | |
| ZGC | | | | |

### 分析要点

- **吞吐量优先**的收集器表现如何？
- **低延迟**的收集器在暂停时间上有什么优势？
- 不同收集器之间的 trade-off 是什么？

---

## 4. 实验 D：四种引用类型验证（推荐完成）

### 实验目标

通过代码验证强引用、软引用、弱引用、虚引用的回收行为。

### 实验代码

**文件**：`code/ReferenceDemo.java`

### 实验步骤

1. **编译代码**：
   ```bash
   cd Day02/code
   javac ReferenceDemo.java
   ```

2. **运行代码**（设置较小堆内存，使软引用更容易被回收）：
   ```bash
   java -Xms20m -Xmx20m -XX:+PrintGCDetails ReferenceDemo
   ```

3. **观察输出**：
   - 强引用：GC 后对象是否存活？
   - 软引用：内存充足时 GC 后对象是否存活？内存不足时呢？
   - 弱引用：GC 后对象是否存活？
   - 虚引用：能否通过 `get()` 获取对象？

### 记录项

| 引用类型 | GC 前 | GC 后（内存充足） | GC 后（内存不足） |
|---------|-------|-----------------|-----------------|
| 强引用 | | | |
| 软引用 | | | |
| 弱引用 | | | |
| 虚引用 | | | |

### 预期现象

- 强引用：GC 后对象仍然存活
- 软引用：内存充足时 GC 后存活，内存不足时被回收
- 弱引用：只要发生 GC 就会被回收
- 虚引用：`get()` 永远返回 `null`，对象被回收后通知放入引用队列

---

## 5. 今日验收（完成即达标）

### 基础验收

- [ ] 能说出 JVM 判断对象存活的两种方式及区别
- [ ] 能说出四种引用类型的回收时机
- [ ] 能说出标记-清除、复制、标记-整理算法的过程和优缺点
- [ ] 至少完成实验 A，并写清楚 GC 日志的关键字段含义

### 进阶验收

- [ ] 完成所有 4 个实验
- [ ] 能说出 CMS 的 4 个阶段及每个阶段的作用
- [ ] 能说出 G1 的 Region 机制和回收过程
- [ ] 能对比不同收集器的适用场景
- [ ] 能回答课件中的面试高频问题

### 验收标准

参考课件最后的检查清单进行自我验收。

---

## 6. 常见问题

### Q1: 我的 JDK 版本不支持某些收集器怎么办？

**A**：
- CMS 在 JDK 14 中已被移除，如果你使用 JDK 14+，跳过 CMS 实验
- ZGC 需要 JDK 11+（Linux）或 JDK 14+（macOS/Windows）
- G1 在 JDK 9+ 是默认收集器

### Q2: GC 日志参数在 JDK 9+ 变了？

**A**：是的。JDK 9 引入了统一日志框架（JEP 158），旧的 `-XX:+PrintGCDetails` 等参数已废弃。请使用 `-Xlog:gc*` 替代。详见实验步骤中的双版本命令。

### Q3: 如何查看当前使用的是哪个收集器？

**A**：
```bash
# 方式1：查看JVM启动参数
java -XX:+PrintCommandLineFlags -version

# 方式2：运行时查看
jinfo -flags <pid>

# 方式3：GC日志中观察收集器名称
```

### Q4: 实验结果和预期不一致？

**A**：
- 确认 JVM 参数是否正确
- 不同 JDK 版本的默认行为可能不同
- 系统负载也可能影响 GC 行为
- GC 是非确定性的，多次运行结果可能略有差异

---

> **提示**：完成实验后，务必在 `02-学习笔记.md` 中记录你的观察结果和思考。
